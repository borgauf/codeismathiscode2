# # -*- mode: org -*- coding: utf-8 -*-
#+TITLE: 
#+AUTHOR:
#+EMAIL: 
#+DATE: 
#+LANGUAGE:  en
# #+INFOJS_OPT: view:showall ltoc:t mouse:underline
#+HTML_HEAD: <link rel="stylesheet" href="./tufte.css" type="text/css">
#+HTML_HEAD: <link rel="stylesheet" href=".//ox-tufte.css" type="text/css">
#+HTML_HEAD_EXTRA: <style>
#+HTML_HEAD_EXTRA: article > div.org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: article > section .org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: div.org-src-container > pre { clear: none; }
#+HTML_HEAD_EXTRA: pre.example {clear: none; }
#+HTML_HEAD_EXTRA: </style>
#+INCLUDE: "./header.org" :minlevel 1
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_FILE_NAME: LittleSchemer2.html
#+OPTIONS: H:15 num:nil toc:nil \n:nil @:t ::t |:t _:{} *:t ^:{} prop:nil
#+OPTIONS: tex:t
#+OPTIONS: html-postamble:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]
# Setup tikz package for both LaTeX and HTML export:
#+LATEX_HEADER: \usepackqqqage{tikz}
#+LATEX_HEADER: \usepackage{commath}
#+LaTeX_HEADER: \usepackage{pgfplots}
#+LaTeX_HEADER: \usepackage{sansmath}
#+LaTeX_HEADER: \usepackage{mathtools}
#+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#
#+PROPERTY: header-args:latex+ :exports results :fit yes
#
#+STARTUP: showall
#+STARTUP: align
#+STARTUP: indent
#+STARTUP: shrink
# This makes MathJax/LaTeX appear in buffer (UTF-8)
#+STARTUP: entitiespretty
# #+STARTUP: logdrawer # This makes pictures appear in buffer
#+STARTUP: inlineimages
#+STARTUP: fnadjust
# #+OPTIONS: html-style:nil
#+html_head_extra: <style> .title { display: none; } </style>
#+html_head_extra: <style> caption.t-bottom { caption-side: bottom; } </style>

* Little Schemer 2

#+begin_figure
#+CAPTION: The Little Schemer putting together a combinator.
[[file:images/LittleSchemerElephant1.png]]
#+end_figure


** Bibliography :noexport:
:PROPERTIES:
:header-args: :dir "/home/galaxybeing/Dropbox/org/codeismathiscode2"
:END:
:RESOURCES:
- [[bibliography:~/Dropbox/org/biblio/ref.bib][Bibliography]]
- [[cite:&friedman1995little]]
:END:


* 

** What are expressions?

As mentioned previously, /functional/ programming, as opposed to
/procedural/ or /imperative/ programming, emphasizes /functions/ as
the computational building blocks. Key is how functions in functional
programming languages behave as if they were true mathematical
functions. This is a great advantage---for reasons we will explore in
detail as we progress.

Computer programming has advanced from the early days of literally
having to give /commands/ imperatively, one after the other, to the
electronic organs of the CPU[fn:1] (and the memory attached to it) in
order to, e.g., perform simple addition or subtraction. For an
analogy, imagine having to tell your body exactly how to breathe. That
would be very restricting, taking up so much of your attention and
concentration. And so your brain simply handles breathing
semi-automatically at a lower, unconscious level. Similarly, in order
to be more productive, programming languages have striven over the
years to /abstract/ the gnarly details of getting data and
calculations handled away from having to literally tell the CPU or the
"bare metal" each and every low-level step of a calculation.

For the time being, let's consider a quick, ad hoc definition of a
function and then later really take the idea of a function apart and
analyze it in a higher math way \\
\\
{{{marginnote(...more about /relations/ in a higher math way
later... /set/ as in set theory sets. Some very formal texts call a
set a /class/ by the way.)}}}  ‚á≤@@html:<font color = "#0d3db3">@@ A
*function* is a /relation/ between a /set/ whose elements are inputs
(the /domain/) and a set whose elements make up outputs (the range)
with the key property that /each input is related to exactly one
output/.@@html:</font>@@[fn:2] \\
\\
Let's also look at a function in terms of /variables/. Recalling the
usual pre-algebra way of denoting a function, i.e., $y = f(x)$, the
symbol $x$ stands for input and is called an *independent variable*,
while the symbol that stands for output, $y$, is called a *dependent
variable*. And so the dependent variable of the range /depends/ on the
independent variable of the domain.[fn:3]

At this point in our journey we need to be clear about what is meant
in the math and CS literature by an *[[https://en.wikipedia.org/wiki/Expression_(mathematics)][expression]]*---a /mathematical/
expression, an /algebraic/ expression, et cetera. Then we will launch
into the next topic in TLS, namely *s-expressions* or /symbolic/
expressions, which are the building blocks of Scheme programs. Here's
Wikipedia's first-paragraph definition of a mathematical expression \\
\\
‚á≤ @@html:<font color = "#0d3db3">@@ In mathematics, an *expression* is
a written arrangement of symbols following the context-dependent,
syntactic conventions of mathematical notation. Symbols can denote
numbers, variables, operations, and functions. Other symbols include
punctuation marks and brackets, used for grouping where there is not a
well-defined order of operations.  @@html:</font>@@ \\
\\
...which is admittedly a bit dense and too general. But then the
article gives the example $7x - 5 = 2$ where the whole thing as one is
considered an /equation/, while the left- and right-hand sides by
themselves are called /expressions/. And then the example of the
inequality $8x - 5 \ge 3$ is referred to as a /formula/, and again, the
$8x - 5$ part and the $3$ part are expressions. But can equations can
be expressions too? After all the basics of an expression, i.e., the
"symbols" and "syntactic conventions," are maintained.

One important trait of expressions (which is very important in
functional programming) is that expressions may be evaluated or
simplified to find equivalent values. The expression $8 \cdot 2 - 5$
simplifies to $16 - 5$ and then evaluates to $11$. And sometimes a
mathematical expression comes from transcribing a statement, e.g.,
"One number is six more than half of another number." So if we
represent the "other number" as $a$ then a mathematical expression of
this statement could be

\begin{align*}
\frac{a}{2} + 6
\end{align*}

Let's give a simplified, more direct definition of an expression \\
\\
‚á≤@@html:<font color = "#0d3db3">@@ An *expression* is a mathematical
phrase that can contain ordinary numbers, variables such as $x$ or $y$
and operators such as the symbols for add, subtract, multiply, divide,
and equals.  @@html:</font>@@ \\
\\
And so an equation (built around an equals sign) can be an expression
after all.[fn:4] If an expression is, as restated from above,
@@html:<font color = "#0d3db3">@@any way of combining numbers and
symbols in a way that is syntactically correct@@html:</font>@@, then

+ $1 + 2$
+ $3x - 5$
+ y = x

are all expressions---while $5+ = 7$ means nothing because its syntax
is garbled. And so an equation is an expression that expresses
/equality/.

/But then is a function an expression?/
The /expression/ $y = f(x)$ tells us that for the function $f$ we have
$x$ as the independent variable and $y$ then /depends/ on which $x$ is
being evaluated.

ùñüùï≠: $y = e^x$ is an expression because, first and foremost, it is
syntactically valid; /and/ it is an equation because of the equals
sign. But is it a function? Just in this form we haven't decided which
is the dependent or the independent value. We could plug in (a)
value(s) for $y$ and get an $x$ /or/ plug in (a) value(s) for $x$ and
get a $y$ as it is now written. To be more specific we could write it
as

\begin{align*}
y = f(x) = e^x
\end{align*}

and now we have established which is independent ($x$) and which is
dependent ($y$).

ùñüùï≠: $7a + 2b + 3c$ is clearly an /algebraic/ expression but it does
not have to be a function, since the symbols $a$, $b$, and $c$ don't
necessarily have to be variable inputs, rather, constants previously
assigned numerical values. But if $a$ is indeed a dependent variable
we would have the function

\begin{align}
f(a)=7a+2b+3c
\end{align}

‚•§ *Food for thought*: $a$ is a dependent variable in (1) and the
symbols $b$ and $c$ must then be constants. But could more than just
$a$ be a variable? If so, how could we express this? How about as a
function of multiple variables?

\begin{align}
f(a,b,c)=7a+2b+3c
\end{align}

(2) tells us all three letter symbols stand for variables. Later when
we define what a Cartesian coordinate system really is, we'll also
touch on the world of /[[https://en.wikipedia.org/wiki/Combinatorics][combinatorics]]/, or the science of counting or
sampling combinations of different sets, which is really what's going
on with this function-expression thingy. \\
\\
{{{marginnote(*Fazit*: German meaning /in conclusion/, /summing up/)}}}
$\mathfrak{Fazit}$: We will indeed say @@html:<font color = "#0d3db3">@@all
functions are expressions.@@html:</font>@@ \\
\\
** S-expressions TLS-style

Now we will discuss the idea of a *symbolic expression* or
*s-expression* as Lisp and Scheme mean it. On page 4 of TLS we
suddenly see, with no explanation or warning, the term /s-expression/

@@html:<span class="schemer">@@ŒíŒπŒ≥ Œ£ŒæŒ∑ŒµŒºŒµœÅ:@@html:</span>@@ Is it true
that this is a list? \\
~(atom turkey) or~ \\
@@html:<span class="schemer">@@ŒõŒπœÑœÑŒªŒµ Œ£ŒæŒ∑ŒµŒºŒµœÅ:@@html:</span>@@ No,
because these are actually two *s-expressions*[fn:5] not enclosed by
parentheses. The first one is a list containing two atoms, and the
second one is an atom.

Again, the discussion progresses by /backing into/ the definition of
sexp's by first giving key examples. This method is the reverse of
what higher math usually does. How? Because higher math will typically
state a rule, a proposition fundamental to the topic at hand, and then
proceed with discussion and examples of what the fundamental law
/implies/, i.e., what facts and uses unfold, are necessitated by that
law. For example, a higher math text might state \\
\\
@@html:<font color = "#0d3db3">@@ The set of counting numbers, the
/natural/ numbers, $\mathbb{N}$, is *closed* under binary operators
addition and multiplication.  @@html:</font>@@ \\
\\
Then a discussion would ensue as to why $\mathbb{N}$ is not
closed[fn:6] under, say, subtraction and division by asking
if@@html:<font color = "#0d3db3">@@ the operation $5 - 6$ result in an
element of $\mathbb{N}$?@@html:</font>@@ No, because evaluating the
expression $5 - 6$ results in $-1$ and $-1 \notin \mathbb{N}$, rather, $-1
\in \mathbb{Z}$ which is the set of all *integers*, i.e., positive and
negative whole numbers along with $0$.

Rather than copy the Big/Little Schemer chat verbatim, we'll just
give the examples directly

ùñüùï≠: ~((atom turkey) or)~ is a list because the two sexp's are grouped
completely inside parentheses. \\
ùñüùï≠: ~xyz~ is an sexp because all atoms are sexp's. \\
ùñüùï≠: ~(x y z)~ is an sexp because it is a list. \\
ùñüùï≠: ~((x y) z)~ is an sexp because all lists are sexp's. \\
ùñüùï≠: ~(how are you doing so far)~ is an sexp because it is a collection
of sexp's enlosed by parentheses. \\
ùñüùï≠: ~(((how) are) ((you) (doing so)) far)~ is a list because it
is a collection of sexp's enclosed by parentheses. \\
ùñüùï≠: The list ~(((how) are) ((you) (doing so)) far)~ has /three/ sexp's which
are ~((how) are)~, ~((you) (doing so))~, and ~far~.[fn:7]

So it's obvious that Scheme is organized into sexp's. But why, how? \\
\\

** S-expression and symbols

The first part of the term s-expression is /symbolic/, but what is
meant by symbolic? Obviously, symbolic is an adjective that means
whatever it is referring to has /symbol-like/
characteristics. Wikipedia starts its article on mathematical symbols
with this simple and probably too general definition \\
\\
@@html:<font color = "#0d3db3">@@A *mathematical symbol* is a figure
or a combination of figures that is used to represent a mathematical
object, an action on mathematical objects, a relation between
mathematical objects, or for structuring the other symbols that occur
in a formula. As formulas are entirely constituted with symbols of
various types, many symbols are needed for expressing all
mathematics.@@html:</font>@@ \\
\\
Before we start going around in circles, what is meant by "figures" is,
e.g.,

+ *decimal digits*, i.e., $0$, $2$, $3$, ...
+ *Latin*, *Greek*, *Hebrew* alphabet characters, i.e., $a$, $b$,
  $\mathbb{C}$, $\beta$, $\rho$, $\Gamma$, $\beth$, $\aleph$, et cetera, which can have
  different weights and typefaces for different uses.
+ Various *operation* and *binder symbols*, i.e., $+$, $-$, $\div$, $\sum$
  for summation, $\int$ for integration, et cetera.

Touching for a moment on the philosophical, we may stop and marvel at
how humans have come to use and manipulate symbols, especially the use
of language. With human language we employ *words* which /symbolize/
real things or abstract concepts. A word can be considered a
/placeholder/ for an object or idea. Some experts say humanity has
only possessed language as a set of words-as-placeholder-symbols for
forty thousand years. Others say from sixty to one-hundred thousand
years. And yet we surely have been anatomically /Homo sapiens/ longer
than we've had language. What did we do with our big brains before we
had language?[fn:8] Obviously, we relied to some extent on intuitions,
i.e., we would see two piles of nuts and only have vague intuitive
notions that there were two piles and that they might differ in
size... But if we just analyze that last sentence we can begin to
appreciate how powerful formal symbolic language can be. Whole logic
systems spring to life once we have set up symbols to stand for things
and ideas. Hence, it's no wonder computing has been called /the
manipulation of symbols/.

Here's a quote from math logician Raymond M. Smullyan's book /The Tao
Is Silent/

#+begin_quote
The knowledge of the ancients was perfect. How perfect? I will tell
you. At first they did not yet know that there were things. This is
the most perfect knowledge; nothing can be added. Next they knew
things but did not yet make distinctions between them. Next they made
distinctions between them but did not yet pass judgements upon
them. When judgement was passed, Tao was destroyed. With the
destruction of Tao, individual preferences come into being.
#+end_quote
{{{marginnote(So is Professor Smullyan saying ignorance is bliss?)}}}
Yes, the rabbit hole of language and symbolism goes deep. But let's
come back to what is meant by a /symbol/ in the computer
world. Basically, a symbol in a computer program represents a place in
the computer's live memory. As we've mentioned before, /[[https://en.wikipedia.org/wiki/Assembly_language][Assembly
language]]/ was the first attempt to represent the various computer
commands and locations in a symbolic way with labels for particular
actions and places in memory. Down through the years /symbolic
computing/ has kept advancing by /abstracting/ more and more of the
low-level computing away through symbolic representations. Again, this
is /declarative/ rather than /imperative/ programming. \\
\\

** Hands-on Scheme

The version of Scheme we will primarily use is [[https://www.gnu.org/software/guile/][Guile]], which is the
official extension language of the [[https://gnu.org/][GNU project]]. A Guile program can be
compiled to run stand-alone like any piece of executable software; but
we will almost exclusively, real-time /interact/ with the "virtual
machine" *[[https://en.wikipedia.org/wiki/Interpreter_(computing)][interpreter]]* of Guile through the *REPL* or the
/read-evaluate-print loop/ user interface. Below we see a screenshot
of a live /interactive/ Guile REPL session

#+begin_figure
#+CAPTION: REPL interface in Emacs buffer.
[[file:images/GuileREPL.png]]
#+end_figure

...which is similar to Linux command line interface, the big
difference being that a Scheme REPL is the visible human input/output
interface to a live Guile Scheme virtual machine "session." How do we
run code with a REPL?

+ By typing it directly into the REPL as in the picture above,
+ by loading a file containing Scheme code into the
  REPL session, e.g., ~> load myfile.scm~,
+ by evaluating org-mode Babel code blocks in an org-mode buffer as
  seen directly below

#+begin_example
#+begin_src scheme :session *littleschemer*
(define pi 3.141592654)
(format #t "pi: ~a" pi)
#+end_src
#+end_example

We will explore Scheme code through liberal use of org-mode Babel code
blocks. Babel code blocks like this interspersed throughout an Emacs
org-mode text file is an excellent form of /[[https://en.wikipedia.org/wiki/Literate_programming][literate programming]]/.

In the code block example above we see Scheme code that will assign a
value to the /symbol/ ~pi~. To evaluate this code we place the cursor
inside the code block and enter ~C-c C-c~, which produces

#+begin_example
#+RESULTS:
: pi: 3.141592654
#+end_example

As we see in the code block's heading above, the two contained
expressions will be evaluated in a specific REPL session named
~*littleschemer*~. Next, let's /not/ ~define~ a symbol, rather, just
feed the session a symbol[fn:10]

#+name: 7758a423-12c0-47ea-bdb1-88fbc753dbb3
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
'mysymbol
#+end_src

#+RESULTS: 7758a423-12c0-47ea-bdb1-88fbc753dbb3
: mysymbol

As we see, Scheme just gives back the unassigned symbol---and nothing
further happens. However, that apostrophe before the symbol ~'mysymbol~
is not part of the symbol ~mysymbol~. In the Lisp/Scheme world this is
known as /quoting/, which turns anything quoted into /literal
data/. Here's a more verbose version of quoting with the same effect

#+name: 6ad87756-e469-4165-aa84-75ff8006b50d
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(quote mysymbol)
#+end_src

#+RESULTS: 6ad87756-e469-4165-aa84-75ff8006b50d
: mysymbol

Why quote? Because Scheme considers any /unquoted/ symbol as assigned
and tries to retrieve or run it. However, when we quote an sexp, we're
telling Scheme to treat it as just data. For example ~(define pi
3.141592654)~ is an assignment, and once evaluated, ~pi~ is known
during the life of the REPL session as the symbol for the value
~3.141592654~. However

#+name: bd2c666b-e533-4c34-b0bb-869674da97b7
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
'(define pi 3.141592654)
#+end_src

#+RESULTS: bd2c666b-e533-4c34-b0bb-869674da97b7
: (define pi 3.141592654)

produces just the literal sexp ~(define pi 3.141592654)~. This "trick"
is a powerful tool in functional languages. Why? Imagine passing a
whole piece of real code *A* as input to another piece of code
*B*. Consider this

#+name: 6141620c-8e02-4495-a488-4bca17cad00d
#+begin_src scheme :session *littleschemer* :results output :exports both
(define pi-def '(define pi 3.141592654))
(format #t "pi-def: ~a" pi-def)
#+end_src

#+RESULTS: 6141620c-8e02-4495-a488-4bca17cad00d
: pi-def: (define pi 3.141592654)

Lots and lots more about this "trick" soon. It's literally the backbone of
functional programming. \\
\\

** Building a function

So we've seen how ~(define pi 3.141592654)~ and ~'(define pi
3.141592654)~ are two different things. As we saw, the second example
is /quoted/, which makes the whole sexp one big chunk of static,
literal data. Good, but as opposed to what exactly?  Intuitively we
can guess that the first unquoted sexp is, yes, /defining/ ~pi~ to be
~3.141592654~. How exactly does this work? \\
\\
@@html:<font color = "#0d3db3">@@ All Scheme code takes the form of
lists, and the first sexp in the list---unless the list is
quoted---serves as the *function* or *operator*, while the rest of the
sexp's in the list are the parts the function or operator will work
on: ~(function sexp1 sexp2 ... sexpN)~ @@html:</font>@@ \\
\\
ùñüùï≠: ~(+ 2 3)~ ...note prefix notation \\
ùñüùï≠: ~(abs -4)~ ... first sexp is always a function or operator \\
ùñüùï≠: ~(+ (* 2 3) 8)~  ... simplify the deepest sexp outward \\
ùñüùï≠: ~(+ 3 4 5 1)~ ... addition prefix notation can take multiple
arguments \\

In each of the above examples the very first item in the list is the
function/operator. For the arithmetic operators like ~+~, ~*~, et
cetera, we see [[https://en.wikipedia.org/wiki/Polish_notation][prefix notation]] with possibly multiple arguments. Now,
let's see a full Scheme function that takes one argument and when
evaluated, produces output[fn:11]

#+name: 48a7817d-f1a4-4d6c-8ce0-578197a0425e
#+begin_src scheme :session *littleschemer* :results output :exports both
(define (celsius->fahrenheit celsius)
  (+ (* 1.8 celsius) 32))  ; figure out temperature conversion
(format #t "fahrenheit: ~a" (celsius->fahrenheit 20)) ; print answer
#+end_src

#+RESULTS: 48a7817d-f1a4-4d6c-8ce0-578197a0425e
: fahrenheit: 68.0

Of the two main sexp's in the code block above, the first

#+name: d12a5049-e63e-490b-8265-161a0707aee5
#+begin_src scheme :eval never :exports code
(define (celsius->fahrenheit celsius)
  (+ (* 1.8 celsius) 32))
#+end_src

is a typical nested list building a function. In this example the
general form is ~(define (function-name arguments)
(calculating-code))~ which has three main sexp's, the last on the next
line and indented for better reading. Note how the calculation code is
a prefix notation multiplication nested inside a prefix notation
addition. In the ~format~ sexp we call the function
~celsius->fahrenheit~ with argument ~20~.

But we're getting ahead of ourselves a bit. Let's get back to
S-expressions.  \\
\\

** S-expression lore

Symbolic programs are programs where symbolic expressions are
manipulated to gain useful output. But what does this actually entail,
how do we /manipulate symbolic expressions/? With Lisp and Scheme
everything is housed in lists---both data and code alike. So far we've
been nudging around how to build working code from lists. Now we'll
explore more deeply what a list as an sexp really is. We'll start with
a more formal look at /s-expressions/ or sexp's.

Technically, formally an sexp is one of two possibilities

+ an *atom*, /or/
+ a *cons cell*

So we've seen the atom before. Recall, an atom is just a symbol object
thing standing alone by itself. In the Scheme world, atoms can do two
things: stand alone or be in a list. And we saw how just one atom
surrounded by a set of parentheses becomes a list. We then saw how
multiple atoms surrounded by a set of parentheses is also a list; how
a set of parentheses surrounding a mixture of atoms and other lists is
a list ... we saw that lists can be nested in lists nested in lists,
ever deeper. Good. But calling an atom a sexp doesn't get us very
far. As we saw earlier, we could type ~'myatom~ into the REPL---and
get ~myatom~ repeated back to us, i.e., no real computation is
happening yet.

Let's consider the second type of sexp given above, the *[[https://en.wikipedia.org/wiki/Cons][cons
cell]]*. This is where the action starts. A *cons cell* is what a Scheme
list really is, so let's look at how a Scheme list comes into
existence. \\
\\
{{{marginnote(We've touched on the idea of an /ordered pair/ before
with Cartesian coordinate pairs where the order of which is first and
second matters...)}}}
@@html:<font color = "#0d3db3">@@ A cons cell is an *ordered pair* of
the form ~(sexp1 . sexp2)~. @@html:</font>@@ \\

Hmm, still rather theory-bound. So what's the connection between these
ordered-pair cons cells and lists? The answer is we use Scheme's
primitive function ~cons~ to create cons cells by fusing two sexp's
together. Let's see an example where two sexp's as atoms are /consed/
together

#+name: 0ab608a3-69a1-4a34-b97b-69c4790214d6
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 1 2)
#+end_src

#+RESULTS: 0ab608a3-69a1-4a34-b97b-69c4790214d6
: (1 . 2)

Scheme gives us back a cons cell.[fn:12] Let's play with this idea

#+name: c53865cf-680c-4aa6-90f7-58b23b98981d
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 1 (cons 2 3))
#+end_src

#+RESULTS: c53865cf-680c-4aa6-90f7-58b23b98981d
: (1 2 . 3)

and

#+name: 007a1668-3dfb-4c10-8b41-74aa1b43a7c4
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 1 (cons 2 (cons 3 4)))
#+end_src

#+RESULTS: 007a1668-3dfb-4c10-8b41-74aa1b43a7c4
: (1 2 3 . 4)

Except for that last dot between ~3~ and ~4~, this looks like a
regular list of numbers, no? So what is the difference between ~(1 2 3
. 4)~ and the regular list ~(1 2 3 4)~?

We seem to be exampling our way into how lists are built in Scheme,
namely, /a bunch of stuff gets *consed* together/. Let's try this
again and watch exactly which parentheses are enclosing what

#+name: f88a772e-6ed9-4431-95c0-c9e82f134b34
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons (cons '(five is a nice number) '(5)) '(but so is six))
#+end_src

#+RESULTS: f88a772e-6ed9-4431-95c0-c9e82f134b34
: (((five is a nice number) 5) but so is six)

What happened this time? For one, we simply embedded one consing
inside another. But this time the inner and outer ~cons~ /consed/ the
sexp's into a real list---and the ~cons~ dots went away. Why and how?
Let's do more examples

#+name: 83598e94-d50a-4d29-badc-16924d0256ec
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 1 '())
#+end_src

#+RESULTS: 83598e94-d50a-4d29-badc-16924d0256ec
: (1)

#+name: 5d30aeef-8da9-47df-a8f9-c86d826e2036
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 1 (cons 2 (cons 3 '())))
#+end_src

#+RESULTS: 5d30aeef-8da9-47df-a8f9-c86d826e2036
: (1 2 3)

Now we see ~cons~ producing regular lists without any /cons pair/
dots. Technically, under the hood, we still have our nested lists of
consing---which means ~(1 2 3)~ is really ~(1 . (2 . (3 . NIL)))~
where in Scheme ~NIL~ is ~'()~ or the *empty list*. We call ~(1 2 3)~
the *[[https://en.wikipedia.org/wiki/Syntactic_sugar][syntactic sugar]]* version, i.e., we're given a more visually
friendly, uncluttered version of a consed-together list.

So ~(1 2 3)~ is really just a visually improved version of ~(cons 1
(cons 2 (cons 3 '())))~.[fn:13] Awkward looking as the naked version
is, it shows the details of how we're doing a particular sort of
/connecting/ or /associating/ ~1~, ~2~, and ~3~ together. But it's
probably not apparent why we need to *cons*-truct a list this
way. Let's take a short "math holiday" to unravel this.

‚åú\\
@@html:<font color = "#0d3db3">@@‚•§ *Math Holiday! ... working binarily* @@html:</font>@@[fn:14]

Back in grade school when we were first being conditioned to perform
arithmetic (rather than actually learning anything of the art of
mathematical abstraction), we would see a stack of numbers like below
and be told to "add them up." But strictly speaking, addition is a
*binary operation*, meaning only two numbers can be added at a time,
not all of these numbers at once

\begin{align*}
\require{enclose}
\begin{array}{r}
1 \\[-3pt]
2 \\[-3pt]
3 \\[-3pt]
4 \\[-3pt]
+ \; \underline{5} \\
15
\end{array}
\end{align*}

Doubtful that anyone can read the [[https://en.wikipedia.org/wiki/Addition][Addition Wikipedia article]] and not
learn something they didn't know about good old addition. For example,
when we tackle a stack of numbers like above we are actually adding
/only two of the numbers at a time/, i.e., /two/ inputs produce /one/
output. So let's start at the top with $1 + 2$, which is $3$. We then
"carry along" this temporary result and add the next number $3$ to it,
and so on. In reality after that first binary operation of $1 + 2$,
the result $3$ becomes the *augend*, while the next number $3$ becomes
the *addend*. The intermediary total of this sum then becomes the next
augend---and so we progress down the stack reassigning the latest sum
to the augend and adding the next addend to it. This is how many
digital logic calculations are done. Lots more later. \\
‚åü

Now with a refreshing math holiday under our belts it should be clear
that ~cons~ as a binary operation must operate similarly, e.g., there
is no such thing as ~(cons 1 2 3)~,[fn:15] rather, ~cons~ is a /binary
operator/ taking one thing and consing it together with one other
thing. This is repeated until done everything is consed together into
a finished list.

ùñüùï≠: When we see nested ~cons~ operations, e.g., ~(cons 1 (cons 2 (cons
3 '())))~, we're seeing precedence-wise[fn:16] the initial /binary/
operation of ~(cons 3 '())~ which is the /list/ ~(3)~. This is
embedded in ~(cons 2 (3))~ which evaluates to ~(2 3)~, which is again
embedded in ~(cons 1 (2 3))~ resulting in ~(1 2 3)~. Thus, creating a
real list with ~cons~ means consing a sexp onto a real list. Also,
~cons~ can only cons two sexp's at a time.

It may seem too soon to go on holidays again, but let's do another
math holiday anyway!

‚åú\\
@@html:<font color = "#0d3db3">@@‚•§ *Math Holiday! ... a brief, gentle
intro to recursion* @@html:</font>@@

*[[https://en.wikipedia.org/wiki/Recursion][Recursion]]* is a central idea in math and CS. Let's take a quick
theoretical look before we actually start doing it with Scheme
code. Consider this simple summation of the natural numbers
$\mathbb{N}$

\begin{align*}
\sum_{i=1}^n i = 1 + 2 + 3 + \ldots + (n - 1) + n
\end{align*}

This simply sums all the counting numbers until $n$. We can also
write a formula for summing $\mathbb{N}$ /recursively/

[continuation soon...]
\\
‚åü
\\
** A /linked/ list is...

In the world of computer science *[[https://en.wikipedia.org/wiki/Data_structure][data structures]]*, a list is more
commonly thought of as a *linked list*. For ~(cons 42 (cons 69 (cons
613 '()))~ or ~(42 . (69 . (613 . '())))~ we see the three individual
/cons cells/ in the image below

#+begin_figure
#+CAPTION: A linked list representation of the list ~(42 69 613)~.
[[file:images/Cons-cells.png]]
#+end_figure

and a handy ascii representation would be

#+begin_example
*---->*---->*---->NIL
|     |     |
v     v     v
42    69   613
#+end_example

In the Lisp-Scheme family we're not so concerned that this is a
/linked/ list, since the actual internal structure of a list doesn't
require any knowledge of *[[https://en.wikipedia.org/wiki/Pointer_(computer_programming)][pointers]]* as does a language like *[[https://en.wikipedia.org/wiki/C_(programming_language)][C]]*. For
C/C++ programmers these diagrams say that a location in memory for a
cons cell with two "compartments" contains a pointer in the first
compartment to, e.g., ~42~, while the other compartment contains a
pointer to the memory address of the next, the adjoining cons
cell. But again, in Scheme we will never deal directly with actual
pointer memory addresses. Nonetheless, with our pointer-based diagrams
we have a train-looking thing with a ~NIL~ or ~'()~ as the
caboose. What would just ~(cons 'b 'c)~ or ~(b . c)~ look like
diagrammatically? It would in fact be a single cons cell

#+begin_figure
#+CAPTION: Single cons cell for ~(cons 'b 'c)~.
[[file:images/bc.png]]
#+end_figure

Here we see the right and left compartments named, the left is called
the ~car~ and the right is called the ~cdr~ compartment. These names
come from many decades ago when Lisp was first developed and deployed
on a mainframe. But they are also Scheme primitive operators like
~cons~. So if ~(cons 'b 'c)~ produces ~(b . c)~ then

#+name: 22c36165-15a5-4220-a2d1-3705302f39e0
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car (cons 'b  'c))
#+end_src

#+RESULTS: 22c36165-15a5-4220-a2d1-3705302f39e0
: b

and

#+name: 5d40cc99-3aef-4090-a5fa-36a392c7775c
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr (cons 'b 'c))
#+end_src

#+RESULTS: 5d40cc99-3aef-4090-a5fa-36a392c7775c
: c

And so they are operators that surgically remove the *head* and the
*tail* of a cons cell. Let's try this again with ~(cons 42 (cons 69 (cons 613 '())))~ or
sugared ~(42 69 613)~

#+begin_figure
#+CAPTION: A linked list representation of the list ~(42 69 613)~ with ~car~ and ~cdr~.
[[file:images/Cons-cells2.png]]
#+end_figure

#+name: 9a5a45ad-86b9-4b5f-8f22-0f853698d9bb
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car '(42 69 613))
#+end_src

#+RESULTS: 9a5a45ad-86b9-4b5f-8f22-0f853698d9bb
: 42

and

#+name: a6c48364-ab5b-4e75-97a0-af4b080056db
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr '(42 69 613))
#+end_src

#+RESULTS: a6c48364-ab5b-4e75-97a0-af4b080056db
: (69 613)

Did this surprised you? Again, ~car~ returns the contents of the first
element of the list, i.e., the *head* of the list; and ~cdr~ returns
the *tail* or the /rest of the list/. Let's look at ~cdr~ without
syntactic sugar

#+name: f3c4f7ce-7668-4d2f-bb58-6bc7e9418f29
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr (cons 42 (cons 69 (cons 613 '()))))
#+end_src

#+RESULTS: f3c4f7ce-7668-4d2f-bb58-6bc7e9418f29
: (69 613)

As we see, Scheme throws back in the sugar, but what happened is the
tail of ~(cons 42 (cons 69 (cons 613 '())))~ was returned, i.e.,
~(cons 69 (cons 613 '()))~ $\rightarrow$ ~(69 613)~. Let's now reverse this

#+name: 2fc9509a-c5de-4455-aea2-b876b7e77e9d
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 42 (cdr '(42 69 613)))
#+end_src

#+RESULTS: 2fc9509a-c5de-4455-aea2-b876b7e77e9d
: (42 69 613)

Here's another example

#+name: 4772d381-118a-4c3d-9704-3d70494d5949
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car '(((five is a nice number) 5) but so is six))
#+end_src

#+RESULTS: 4772d381-118a-4c3d-9704-3d70494d5949
: ((five is a nice number) 5)

and

#+name: 95063d6e-c9c5-450b-9d69-d0d110ae5242
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr '(((five is a nice number) 5) but so is six))
#+end_src

#+RESULTS: 95063d6e-c9c5-450b-9d69-d0d110ae5242
: (but so is six)

‚åú \\
@@html:<font color = "#4715b3">@@ ‚á≤ Try to glue ~((five is a nice
number) 5)~ and ~(but so is six)~ back together with ~cons~
@@html:</font>@@ \\
‚åü




So is ~(b . c)~ a true, /proper/ list? No, it is called an /improper/
list or a /dotted list/ since we have just a single cons cell with ~2~
in the /cdr/ position. The final /cdr/ position of the last cons cell
must be consed with the ~nil~ or the /empty set/. By this definition
~(cons 1 '())~ is a proper list, but something like ~(a b c . d)~ has
as the last /cdr/ ~d~ which is not ~nil~, i.e., ~'()~.


#+name: 9b2d2b89-3eae-46c7-8cfa-0cc8b0a8ef01
#+begin_src scheme :session *littleschemer* :results verbatim
(cons 1 '())
#+end_src

#+RESULTS: 9b2d2b89-3eae-46c7-8cfa-0cc8b0a8ef01
: (1)

#+name: 1850bca2-9e37-4ce1-8641-bcef322e4e84
#+begin_src scheme :session *littleschemer* :results verbatim
(cons 1 (cons 2 (cons 3 '())))
#+end_src

#+RESULTS: 1850bca2-9e37-4ce1-8641-bcef322e4e84
: (1 2 3)





#+name: 4232bfa8-5cd3-417a-a6d0-5b62aace9e11
#+begin_src scheme :session *littleschemer* :results verbatim
(list 1 2 3)
#+end_src

#+RESULTS: 4232bfa8-5cd3-417a-a6d0-5b62aace9e11
: (1 2 3)



#+INCLUDE: "./footer.org" :minlevel 1

* Footnotes

[fn:1] *CPU*: central processing unit, the calculation "brains" of a
computer.

[fn:2] This important quality of a function was touched on in the
preface.

[fn:3] In pre-algebra a function is typically graphed with the
horizontal axis representing the /independent variable/ and the
vertical axis representing the /dependent variable/. \\
[[file:images/Polynomialdeg2.png]] \\
In this idea of the function, y is the /dependent variable/ and x is
the /independent variable/.

[fn:4] What follows was taken from [[https://www.reddit.com/r/mathematics/comments/wseco9/is_function_an_expression/][this]] reddit discussion.

[fn:5] We will use *sexp* the abbreviation for S-expression.

[fn:6] A set of elements is *closed* under a binary operation if by
applying the operation to any two elements of the set the result is
also an element of the set. For example, $2 + 2$ is $4$, which is also
an element of the natural numbers $\mathbb{N}$.

[fn:7] At this point you might be getting lost in all the
parentheses. Don't worry, Emacs and other editors for Lisp and Scheme
have parentheses-matching highlighting so you always know which
enclosing set of parentheses you are in.

[fn:8] ...some suggest telepathy...

[fn:10] From now on for visual purposes we will forego the code block
wrappers , i.e., ~#+begin_src scheme ... #+end_src~, and just display
the code and the results. When in doubt about exactly what the code
block wrapper should be, consult the raw version of this page.

[fn:11] Anything following a ";" is a /comment/ for the rest of that
line and is not evaluated, rather, just passed on. However, with
org-mode Babel's literate programming we need far less in-code
comments since we can make all the commentary we need before and after
the block.

[fn:12] This is also referred to as /dotted pair/.

[fn:13] Realize of course that \\
~(1 . (2 . (3 . NIL)))~ \\
is just the dotted symbolic way of expressing \\
~(cons 1 (cons 2 (cons 3 '())))~. \\
The dotted version doesn't work as actual Scheme code.

[fn:14] [[https://en.wikipedia.org/wiki/Binary_operation][This Wikipedia article on binary operations]] is quite
abstract-formal, but we'll be getting into this lore meticulously as
we progress. It, like all of higher math, assumes set theory, which is
also the basis of much computer science theory.

[fn:15] Some Scheme REPLs will give the error ~wrong number of
arguments~ because it was expecting exactly two inputs.

[fn:16] *precedence* is the order in which a simplification
follows. Parentheses are usually the highest precedence, e.g., $4 \cdot
(2 + 3) = 20$ because by parenthesizing the $(2 + 3)$ we created
precedence over the multiplication.
