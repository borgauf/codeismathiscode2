<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-03-14 Fri 15:31 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="./tufte.css" type="text/css">
<link rel="stylesheet" href="./ox-tufte.css" type="text/css">
<style>
article > div.org-src-container {
width: var(--ox-tufte-content-width);
max-width: var(--ox-tufte-content-width);
clear: none;
}
article > section .org-src-container {
width: var(--ox-tufte-src-code-width);
max-width: var(--ox-tufte-src-code-width);
clear: none;
}
div.org-src-container > pre { clear: none; }
pre.example {clear: none; }
</style>
<style> .title { display: none; } </style>
<style> caption.t-bottom { caption-side: bottom; } </style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-euler',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<article id="content" class="content">
<div class="header">
<link rel="stylesheet" href="hamb.css">
<link rel="stylesheet" href="tufte.css">
<link rel="stylesheet" href="ox-tufte.css">
<img src="./images/UNPendulumTop.png"  style="padding: 0px 0px 0px 0px" alt="United Nations pedulum" class="left">


<p>

<nav role="navigation">
  <div id="menuToggle">
    <!--
    A fake / hidden checkbox is used as click reciever,
    so you can use the :checked selector on it.
    -->
    <input type="checkbox" />
    
    <!--
    Some spans to act as a hamburger.
    
    They are acting like a real hamburger,
    not that McDonalds stuff.
    -->
    <span></span>
    <span></span>
    <span></span>
    
    <!--
    Too bad the menu has to be inside of the button
    but hey, it's pure CSS magic.
    -->
    <ul id="menu">
      <a href="index.html" target="_blank"><li>Home</li></a>
      <a href="blog.html" target="_blank"><li>Blog</li></a>
      <a href="preface.html" target="_blank"><li>Preface</li></a>
      <a href="preliminaries.html" target="_blank"><li>Rabbit Holes</li></a>
      <li>Numbers</li>
      <ul>
         <a href="HRGettingStarted1.html" target="_blank"><li>Getting Started 1</li></a>
         <a href="HRGettingStarted2.html" target="_blank"><li>Getting Started 2</li></a>
         <a href="numbers1.html" target="_blank"><li>Numbers 1</li></a>
         <a href="numbers2.html" target="_blank"><li>Numbers 2</li></a>
      </ul>
    </ul>
  </div>
</nav>
</div>
</p>
<section id="outline-container-org0ce0959" class="outline-2">
<h2 id="org0ce0959">STEM Club 1</h2>
</section>
<section id="outline-container-org53652d1" class="outline-2">
<h2 id="org53652d1"></h2>
<div class="outline-text-2" id="text-org53652d1">
</div>
<div id="outline-container-orgb948b55" class="outline-3">
<h3 id="orgb948b55">Doing math with computers</h3>
<div class="outline-text-3" id="text-orgb948b55">
<p>
<b>The birth of mathematics</b>:
</p>

<blockquote>
<p>
Caveman #1 (looking at flock of birds): Many. <br>
Caveman #2: <b>How</b> many?
</p>
</blockquote>

<p>
<b>Q</b>: Why do we do STEM? <br>
<b>A</b>: Because somebody will pay us to do science, technology,
engineering, and especially mathematics for them.
</p>

<p>
<b><i>Where</i> is math?</b><label id='fnr.1' for='fnr-in.1.572549' class='margin-toggle sidenote-number'><sup class='numeral'>1</sup></label><input type='checkbox' id='fnr-in.1.572549' class='margin-toggle'><span class='sidenote'><sup class='numeral'>1</sup>
We&rsquo;ll discuss another possibility, namely, the Platonic
belief math is just out there in the universe, later.
</span>
</p>

<ol class="org-ol">
<li>In our brains.</li>
<li>In math books and papers.</li>
<li>On classroom white/black boards.</li>
<li>Built into various mechanical devices</li>
<li>In digital computing devices as circuitry and software.</li>
</ol>

<p>
&#x2026;but, yes, now more than ever #5. So what does it mean to have math
expressed in software.
</p>

<p>
<b>How do computers &ldquo;compute&rdquo; stuff?</b><label id='fnr.2' for='fnr-in.2.4993595' class='margin-toggle sidenote-number'><sup class='numeral'>2</sup></label><input type='checkbox' id='fnr-in.2.4993595' class='margin-toggle'><span class='sidenote'><sup class='numeral'>2</sup>
Let&rsquo;s watch <a href="https://youtu.be/8xPRn9weLYg?si=5fplvY_vDQD2dbHb">this video</a> (semi-)realistically depicting a STEM
environment. No magic, just people taking math out of books and
putting it into their technology.
</span>
</p>

<ul class="org-ul">
<li>Develop algorithms from math</li>
<li>Encode algorithms in programming language</li>
<li>Run code on device</li>
</ul>

<p>
In other words, we&rsquo;re taking the math out of books, papers, off
blackboards, out of brains, reverse-engineering mechanical
devices&#x2014;and packing it into digital computing devices, mainly in the
form of software, code. And with the digital computing devices count
about to exceed <i>three times</i> the world&rsquo;s human population, that&rsquo;s a
big deal.
</p>
</div>
</div>
<div id="outline-container-orgff52af2" class="outline-3">
<h3 id="orgff52af2">Basic fractions on the computer</h3>
<div class="outline-text-3" id="text-orgff52af2">
<p>
What we call <b><a href="https://en.wikipedia.org/wiki/Fraction">fractions</a></b> in everyday life and are written in the form
\(\frac{a}{b}\) are either meant to represent a <b>ratio</b>, i.e., \(a : b\)
and spoken \(a\) to \(b\) or \(a\) is to \(b\), or, more commonly, to imply \(a
\div b\), i.e., \(b\) divides (into) \(a\). Although we normally call the
<i>outcome</i> of division \(a \div b\) the <b>quotient</b> (with a possible
remainder), a fraction as a whole is called a quotient as well
</p>

\begin{align*}
\text{quotient}\;\left\{ \quad \begin{array}{l}
\underline{1} & \leftarrow \text{dividend or numerator} \\[-5pt]
2 &  \leftarrow \text{divisor or denominator}
\end{array} \right.
\end{align*}

<p>
<b><a href="https://en.wikipedia.org/wiki/Rational_number">Rational numbers</a></b> are numbers that are expressed in the fraction form
\(\frac{a}{b}\) where both \(a\) and \(b\) are <b>integers</b> and \(b \ne 0\). That
means, e.g., \(\frac{\sqrt{2}}{2}\) is not a rational number, but is
still considered a fraction. And so we can call any rational number a
fraction, but not all fractions are rational numbers.<label id='fnr.3' for='fnr-in.3.5738824' class='margin-toggle sidenote-number'><sup class='numeral'>3</sup></label><input type='checkbox' id='fnr-in.3.5738824' class='margin-toggle'><span class='sidenote'><sup class='numeral'>3</sup>
A fraction can be resolved into a <b><a href="https://en.wikipedia.org/wiki/Fraction#Decimal_fractions_and_percentages">decimal fraction</a></b>, e.g.,
\(\frac{3}{4}\) is \(0.75\). But even repeating decimal, e.g.,
\(\frac{1}{3} = 0.333\ldots\) where the number to the right of the
decimal is an <b>infinite series</b>, i.e., \(\frac{3}{10} + \frac{3}{100} +
\frac{3}{1000} \ldots\).
</span> The set of
rational numbers is denoted by \(\mathbb{Q}\), which, again, stands for
<i>quotient</i>.
</p>



<p>
Let&rsquo;s start with something presumably simple like how to do
fractions&#x2014;specifically, <i>adding, subtracting unlike denominator
fractions</i>&#x2014;on the computer. We&rsquo;ll first dive into the world of
number theory and its concentration on the behavior of prime
numbers. So what is the working definition of a prime whole number?
</p>

<p>
<font color = "#4715b3"> ‚•§ A <b>prime number</b> is an integer
that can only be <i>divided evenly</i> (producing no remainder) by \(1\) or
itself.  </font> <br>
<br>
The opposite of a prime number is a <b>composite number</b>, i.e., an
integer that is a <i>multiple</i> of other numbers beside \(1\) and the
number, let&rsquo;s call it \(n\), itself. With composites there does exist a
number, call it \(d\), between \(1\) and \(n\) that will evenly divide
it. There are many consequences of these two number opposites. One is
the fact that integers are made up of primes
</p>

<p>
<font color = "#4715b3"> ‚á≤ Theorem: <b>Fundamental Theorem of
Arithmetic</b> <br>
Every positive integer \(ùëõ \gt 1\) can be represented in exactly one way
as a product of prime powers.</font>
</p>


<ul class="org-ul">
<li><b>Q</b>: What is meant by prime <i>powers</i>, why not just primes? <br></li>
<li><b>A</b>: By &ldquo;prime power&rdquo; we simply mean a prime raised to a
power. Consider these <i>composite numbers</i> broken down into products
of prime powers</li>
</ul>

\begin{align*}
4 &= 2^2 \\
8 &= 2^3 \\
12 &= 2^2 \cdot 3^1 \\
25 &= 5^2 \\
50 &= 2^1 \cdot 5^2 \\
72 &= 2^3 \cdot 3^2 \\
128 &= 2^7 \\
\ldots
\end{align*} 

<p>
Let&rsquo;s use Scheme&rsquo;s function <code>expt</code> to find \(2^7\)
</p>

<div class="org-src-container">
<pre class="src src-scheme" id="orgde0f8b8"><span class="org-rainbow-delimiters-depth-1">(</span>expt 2 7<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
128
</pre>


<p>
This idea of multiplying unique sets of primes to get any whole number
is an almost mysterious thing in mathematics. The <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano Axioms</a>,
supposedly the most bedrock foundation of mathematics, says if we
start with zero we can get any of the natural counting numbers,
\(\mathbb{N}\),<label id='fnr.4' for='fnr-in.4.8061131' class='margin-toggle sidenote-number'><sup class='numeral'>4</sup></label><input type='checkbox' id='fnr-in.4.8061131' class='margin-toggle'><span class='sidenote'><sup class='numeral'>4</sup>
In higher math the <b>natural counting numbers</b>
\(\{1,2,3,4,\ldots\}\) are signified by \(\mathbb{N}\), while the
<b>integers</b> \(\{\ldots,-2,-1,0,1,2,\ldots\}\) are \(\mathbb{Z}\). Both are
whole numbers.
</span> by simply adding &ldquo;one more&rdquo; over and over.<label id='fnr.5' for='fnr-in.5.6442931' class='margin-toggle sidenote-number'><sup class='numeral'>5</sup></label><input type='checkbox' id='fnr-in.5.6442931' class='margin-toggle'><span class='sidenote'><sup class='numeral'>5</sup>
Fundamental to Peano&rsquo;s approach is recursion and induction,
which we will explore in depth soon.
</span>
But we can also &ldquo;get&rdquo; any \(n \in \mathbb{N}\) by multiplying sets of
primes. Hence, we can almost say, prime numbers <i>necessitate</i> (bring
into existence?) multiplication.
</p>

<p>
Let&rsquo;s jump way ahead just for a moment. <a href="https://gemini.google.com/app">Google Gemini</a> produced this
Haskell code when the keywords <i>haskell prime factors of a number</i>
were entered into a Gemini search<label id='fnr.6' for='fnr-in.6.852288' class='margin-toggle sidenote-number'><sup class='numeral'>6</sup></label><input type='checkbox' id='fnr-in.6.852288' class='margin-toggle'><span class='sidenote'><sup class='numeral'>6</sup>
This is not serious number factoring code. The &ldquo;art&rdquo; of
factoring numbers is at the heart of modern cryptography. In fact, it
is still unknown whether any variation of factoring code running on
conventional computers can factor any significantly large number in a
reasonable amount of time. This issue belongs to the realm of
<b><a href="https://en.wikipedia.org/wiki/Computability_theory">computability theory</a></b> and was the instigator to the digital computer.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org0c8fbd7"><span class="org-haskell-definition">primeFactors</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Integer</span><span class="org-rainbow-delimiters-depth-1">]</span> 
<span class="org-haskell-definition">primeFactors</span> n <span class="org-haskell-operator">=</span> go <span class="org-rainbow-delimiters-depth-1">[</span>2<span class="org-haskell-operator">..</span><span class="org-rainbow-delimiters-depth-1">]</span> n
  <span class="org-haskell-keyword">where</span>
    go primes num 
      <span class="org-haskell-operator">|</span> num <span class="org-haskell-operator">==</span> 1 <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-1">[]</span></span> 
      <span class="org-haskell-operator">|</span> head primes <span class="org-haskell-operator">*</span> head primes <span class="org-haskell-operator">&gt;</span> num <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>num<span class="org-rainbow-delimiters-depth-1">]</span> 
      <span class="org-haskell-operator">|</span> num <span class="org-haskell-operator">`mod`</span> head primes <span class="org-haskell-operator">==</span> 0 <span class="org-haskell-operator">=</span> head primes <span class="org-haskell-constructor">:</span> go primes <span class="org-rainbow-delimiters-depth-1">(</span>num <span class="org-haskell-operator">`div`</span> head primes<span class="org-rainbow-delimiters-depth-1">)</span> 
      <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> go <span class="org-rainbow-delimiters-depth-1">(</span>tail primes<span class="org-rainbow-delimiters-depth-1">)</span> num
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org1520f12"><span class="org-haskell-definition">primeFactors</span> 120
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:810:1-12: error:
    Variable not in scope: primeFactors :: t0 -&gt; t
</pre>


<p>
Too much all at once. Better to break things down, like the approach
taken in <a href="https://www.collegepublications.co.uk/computing/?00004"><i>The
Haskell Road to Logic, Maths, and Programming</i></a> by Doets and van
Eijck. They start with the
</p>
</div>
<div id="outline-container-orgf4316c4" class="outline-4">
<h4 id="orgf4316c4">Prime number test</h4>
<div class="outline-text-4" id="text-orgf4316c4">
<p>
Again, prime numbers: \(2, 3, 5, 7, 11, 13,\ldots\), divisible only by
\(1\) or the number itself.
</p>

<p>
‚á≤ Definition <b>Divides</b>
</p>

<p>
<font color = "#4715b3"> If \(a, b \in \mathbb{Z}\), the
integers, we say that \(a\) divides \(b\), written \(a \mid b\), if \(a \cdot c =
b\) for some \(c ‚àà \mathbb{Z}\). In this case, we say \(a\) is a <i>divisor</i>
of \(b\). We say that \(a\) does not divide \(b\), written \(a \nmid b\), if
there is no \(c ‚àà \mathbb{Z}\) such that \(a \cdot c = b\).  </font>
</p>

<p>
Division is the inverse of multiplication, e.g., \(\frac{6}{3} = x\)
is identical to \(x \cdot 3 = 6\) as we&rsquo;ve seen in basic algebra. Defining
<i>divides</i> in terms of multiplication by another whole number implies
division without a remainder. \(2 \mid 6\) (\(2\) <i>divides</i> \(6\)) and \(-3
\mid 15\) (\(-3\) <i>divides</i> \(6\)). All integers divide \(0\), but only \(0\)
divides \(0\). This is why division by \(0\) is problematic. \(q =
\frac{a}{0}\) would imply \(q \cdot 0 = a\), but if \(a\) is not zero, then
this is nonsense.
</p>

<p>
Now, let&rsquo;s turn <b>divides</b> into code
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgf718da5"><span class="org-haskell-definition">divides</span> d n <span class="org-haskell-operator">=</span> rem n d <span class="org-haskell-operator">==</span> 0
</pre>
</div>

<p>
This is simple, but there&rsquo;s a lot going on for the beginner. We see
<code>=</code>, the <i>is defined as</i> or <i>is by definition equal to</i> symbol in
Haskell&#x2014;which makes anything using it an <b>equation</b>, i.e., <code>divides
d n = rem n d == 0</code> is an equation. We also see on the right hand side
of <code>=</code> the double-equals symbol <code>==</code> for <b>identity</b>. Let&rsquo;s look into
exactly what an identity is in the math world.
</p>

<p>
‚á≤ Definition <b>Identity</b>
</p>

<p>
<font color = "#4715b3"> An <b>identity</b> is a type of
<i>equality</i> relating one mathematical expression \(A\) to another
mathematical expression \(B\), such that \(A\) and \(B\) (which might
contain some variables) produce the same value for all values of the
variables within a certain domain of discourse.  </font>
</p>

<p>
Unfortunately, two symbols are used to indicate identity. For example
</p>

\begin{align*}
(a + b)^2 = a^2 + 2ab + b^2
\end{align*}

<p>
uses the \(=\) equals sign to indicate <i>identical values</i> are guaranteed
given any specific \(a\) or \(b\).<label id='fnr.7' for='fnr-in.7.711221' class='margin-toggle sidenote-number'><sup class='numeral'>7</sup></label><input type='checkbox' id='fnr-in.7.711221' class='margin-toggle'><span class='sidenote'><sup class='numeral'>7</sup>
In Haskell, everything has a value. This is an abstraction
meant to keep things highly mathematical, i.e., above imperative
programming where evaluating code leads to state changes. With
Haskell, the evaluation of code yields values intentionally not
involved with state changes.
</span> Another identity would be
</p>

\begin{align*}
sin^{2}\theta + cos^{2}\theta = 1
\end{align*}

<p>
Again, we mean the left- and right-hand sides are identical
mathematically, as in, both sides have identical values, although
they&rsquo;re obviously different symbols.<label id='fnr.8' for='fnr-in.8.3252421' class='margin-toggle sidenote-number'><sup class='numeral'>8</sup></label><input type='checkbox' id='fnr-in.8.3252421' class='margin-toggle'><span class='sidenote'><sup class='numeral'>8</sup>
The <a href="https://en.wikipedia.org/wiki/Pythagorean_trigonometric_identity">proof/derivation</a> of \(sin^{2}\theta + cos^{2}\theta = 1\) is usually included
in trigonometry texts. This is just one proven identity. But the
general idea of <b><a href="https://en.wikipedia.org/wiki/Rewriting">term rewriting</a></b>, i.e., the art of redoing an
expression into an identical one, is an important field in math and
computability.
</span> <i>Which means they are
interchangeable</i>. Which means when solving a trig problem, you can
substitute in one for the other. Keep track of the subtle difference
between <i>is defined as</i> and <i>identical values</i>.
</p>

<p>
Having said all this, the Haskell operator <code>==</code> and its opposite <code>/=</code>
are actually functions that take two <i>formal arguments</i> and return a
&ldquo;decision&rdquo; of whether they are or are not identical. In our <code>divides</code>
code we have <code>rem</code> which takes two arguments and returns only the
remainder of dividing the first argument by the second
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgf42ba8d"><span class="org-haskell-definition">rem</span> 8 4
</pre>
</div>

<pre class="example">
0
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org5c0e423"><span class="org-haskell-definition">rem</span> 9 5
</pre>
</div>

<pre class="example">
4
</pre>


<p>
i.e., <code>rem</code> throws away the quotient and keeps just the
remainder.
</p>

<p>
In Haskell, being a <b>typed language</b> means that every expression in
the program has a type&#x2014;such as integer, real number, characters in
an alphabet, etc.&#x2014;and these types are checked by the Haskell
compiler to make sure we&rsquo;re not doing something strange, e.g., adding
the number \(5\) to the letter \(z\), before the program is run. This type
checking is a fundamental part of Haskell&rsquo;s design and contributes
significantly to its safety, reliability, and expressiveness. The
Haskell REPL command <code>:type</code> (<code>:t</code> for short) will give us back the
<i>type signature</i> of <code>rem</code>, i.e., what type(s) <code>rem</code> can take for input
arguments, how many, and what it will return as its value when
evaluated
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgc025086"><span class="org-haskell-constructor">:</span>t rem
</pre>
</div>

<pre class="example">
rem :: Integral a =&gt; a -&gt; a -&gt; a
</pre>


<p>
In this case <code>a</code> is a <b>unconstrained type variable</b> instead
of one specific type. This means <code>rem</code> can take different types for
input. What different types? The signature starts with <code>Integral a
=&gt;</code>, which means any type of the <code>Integral</code> class. Hold that
thought&#x2026;
</p>

<p>
To the right of <code>Integral =&gt;</code> we see the chain <code>a -&gt; a -&gt; a</code>. This is
the actual breakdown of the function type-wise. The type of the
function&rsquo;s output is always the last symbol on the far right, while
the <code>a -&gt; a</code> indicates two input arguments. Which makes sense---<code>rem</code>
takes two arguments and returns one answer.
</p>

<p>
Back to <code>Integral</code>. Which is a <b>type class</b> declared internally in
Haskell. The <code>Integral a =&gt;</code> prefix in the type signature of <code>rem</code>
says <code>a</code> can be any of the individual types that have &ldquo;registered&rdquo;
with the type class <code>Integral</code>. Let&rsquo;s unpack the <code>Integral</code> type class
with the Haskell REPL command <code>:info</code> (or just <code>:i</code>)<label id='fnr.9' for='fnr-in.9.1165058' class='margin-toggle sidenote-number'><sup class='numeral'>9</sup></label><input type='checkbox' id='fnr-in.9.1165058' class='margin-toggle'><span class='sidenote'><sup class='numeral'>9</sup>
<code>:t</code> and <code>:i</code> are your best friends when navigating the Haskell
type world.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org496e461"><span class="org-haskell-constructor">:</span>info <span class="org-haskell-constructor">Integral</span>
</pre>
</div>

<pre class="example" id="orgd9cd98a">
type Integral :: * -&gt; Constraint
class (Real a, Enum a) =&gt; Integral a where
  quot :: a -&gt; a -&gt; a
  rem :: a -&gt; a -&gt; a
  div :: a -&gt; a -&gt; a
  mod :: a -&gt; a -&gt; a
  quotRem :: a -&gt; a -&gt; (a, a)
  divMod :: a -&gt; a -&gt; (a, a)
  toInteger :: a -&gt; Integer
  {-# MINIMAL quotRem, toInteger #-}
  	-- Defined in ‚ÄòGHC.Real‚Äô
instance Integral Int -- Defined in ‚ÄòGHC.Real‚Äô
instance Integral Integer -- Defined in ‚ÄòGHC.Real‚Äô
instance Integral Word -- Defined in ‚ÄòGHC.Real‚Äô
</pre>

<p>
We&rsquo;ll dive deeper into the whole type class story later, but for now
just know that <code>Integral</code> provides <i>generic</i> whole-number division and
remainder functions, <code>quot</code>, <code>rem</code>, <code>div</code>, <code>mod</code>, <code>quotRem</code>, <code>divMod</code>,
and <code>toInteger</code>, which are then customized by the specific types
<code>Int</code>, <code>Integer</code>. This output tells us that any type that wants to
have the functions <code>quot</code>, <code>rem</code>, &#x2026;, <code>toInteger</code> needs to have a
registered <i>instance</i> with type class <code>Integral</code>. Which means the
types <code>Int</code>, <code>Integer</code>, and <code>Word</code> do indeed have their own specific
versions of the basic functions <code>quot</code>, <code>rem</code>,&#x2026;
</p>

<p>
Now, back to <code>divides d n = rem n d == 0</code>, where the left-hand side
<code>divides d n</code> is really just a nice <i>is-defined-as</i> wrapper for the
<i>identity</i> <code>rem n d == 0</code>, i.e., we have created a Haskell version of
\(d \mid n\). Let&rsquo;s look at its type
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org0c96d26"><span class="org-haskell-constructor">:</span>t divides
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-7: error: Variable not in scope: divides
</pre>


<p>
Haskell reports <code>divides</code> takes two arguments of type <code>a</code>,
meaning, as we just discussed, they could be any of the three types
instance registration with <code>Integral</code>, and gives back a value of type
<code>Boolean</code>. So what does this <code>Boolean</code> mean? A <code>Boolean</code> is a type of
<i>truth value</i>. While the set of natural numbers \(\mathbb{N} =
\{0,1,2,\ldots\}\) is endless, the <code>Boolean</code> set is made up of just two
elements, \(\{\top, \bot\}\) (logic symbols for <i>top</i> or <i>truth</i> and
<i>bottom</i> or <i>falsity</i>) or in Haskell simply <code>True</code> and <code>False</code>.
</p>

<p>
In the type signature for <code>divides</code> we see the two input arguments <code>n</code>
and <code>d</code>, but why does the code <code>...rem n d == 0</code> return as its value
either a <code>True</code> or <code>False</code>. Because in the realm of Haskell,
<i>everything has a value</i>. While \(sin^{2}\theta + cos^{2}\theta = 1\) is indeed an
identity, what is the <i>value</i> of this identity? Here we enter the
realm of mathematical logic. While the value of the left-hand side,
\(sin^{2}\theta + cos^{2}\theta\), becomes whatever \(\theta\) we plug in, and the value of the
right-hand side, \(1\), is just \(1\), the <i>value of the identity as a
whole</i> is either true or false. And so the Haskell identity operator
<code>(==)</code> /returns the value <code>True</code> or <code>False</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org50a2617"><span class="org-haskell-constructor">:</span>t <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
</pre>


<p>
Again, we see <code>a</code> as a type variable, meaning more than one type is
possible. And we see reference to a type class. This time the <code>Eq a
=&gt;</code> indicates whatever actual types <code>a</code> is, those types must each be
registered with the type class <code>Eq</code>. And what is <code>Eq</code>?
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org648c2f4"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</pre>
</div>

<pre class="example" id="org530237a">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Integer -- Defined in ‚ÄòGHC.Num.Integer‚Äô
instance (Eq a, Eq b) =&gt; Eq (Either a b)
  -- Defined in ‚ÄòData.Either‚Äô
instance Eq a =&gt; Eq (Maybe a) -- Defined in ‚ÄòGHC.Maybe‚Äô
instance Eq a =&gt; Eq (Ratio a) -- Defined in ‚ÄòGHC.Real‚Äô
...
instance Eq Bool -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Char -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Double -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Float -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Int -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Ordering -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq a =&gt; Eq (Solo a)
  -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq Word -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
instance Eq a =&gt; Eq [a] -- Defined in ‚Äòghc-prim-0.9.1:GHC.Classes‚Äô
</pre>

<p>
As the ellipsis (&#x2026;) indicate, much was cut out for brevity. The idea
behind <code>Eq</code> is mathematical logic equality or <b>equivalence</b><label id='fnr.10' for='fnr-in.10.3919073' class='margin-toggle sidenote-number'><sup class='numeral'>10</sup></label><input type='checkbox' id='fnr-in.10.3919073' class='margin-toggle'><span class='sidenote'><sup class='numeral'>10</sup>
In mathematical logic statements, expressions \(p\) and \(q\) are
<b><a href="https://en.wikipedia.org/wiki/Logical_equivalence">logically equivalent</a></b> if they have the same <i>truth value</i> in every
case of possible inputs for \(p\) and \(q\). Moral of the story: Keep
<i>is-defined-as</i> <code>=</code> separate from <i>equivalence</i> <code>==</code> (or
non-equivalence <code>/+</code>).
</span>
</p>

<p>
‚•§ <b>Side note</b> establishing equivalence <br>
</p>

<p>
It may be obvious that \(1\) is equivalent to \(1\), and all the
<code>Integer</code>, <code>Double</code>, etc. numbers are equal in value to themselves,
but what if we have created our own data type, say
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org8948797"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Color</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Green</span> <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span>,<span class="org-haskell-constructor">Read</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Can we <i>add</i> these self-made colors? Not really
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org94dc380"><span class="org-haskell-constructor">Red</span> <span class="org-haskell-definition">+</span> <span class="org-haskell-constructor">Yellow</span>
</pre>
</div>

<pre class="example" id="org38570f5">
&lt;interactive&gt;:628:5: error:
    ‚Ä¢ No instance for (Num Color) arising from a use of ‚Äò+‚Äô
    ‚Ä¢ In the expression: Red + Yellow
</pre>

<p>
&#x2026;meaning our <code>Color</code> type does not have addition defined.<label id='fnr.11' for='fnr-in.11.7288065' class='margin-toggle sidenote-number'><sup class='numeral'>11</sup></label><input type='checkbox' id='fnr-in.11.7288065' class='margin-toggle'><span class='sidenote'><sup class='numeral'>11</sup>
Technically only numbers can be added, subtracted,
etc. For addition, e.g., non-number objects are <i>aggregated</i>.
</span> The
error message indicates the type class <code>Num</code> doesn&rsquo;t have an
<i>instance</i> of <code>Color</code> registered with it. Can we <i>compare</i> colors for
order or equivalence? Not yet. But if we specifically create an
instance for <code>Eq</code> telling Haskell what is, e.g., equivalent
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orga4ab287"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Eq</span> <span class="org-haskell-type">Color</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>      <span class="org-comment-delimiter">-- </span><span class="org-comment">could also be (==) Red Red = True</span>
  <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-constructor">Green</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Green</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>         <span class="org-comment-delimiter">-- </span><span class="org-comment">by now anything else must be false</span>
</pre>
</div>

<p>
we now can test for equivalence
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org39af42c"><span class="org-haskell-constructor">Blue</span> <span class="org-haskell-definition">==</span> <span class="org-haskell-constructor">Blue</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:824:1-4: error: Data constructor not in scope: Blue

&lt;interactive&gt;:824:9-12: error: Data constructor not in scope: Blue
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="orgb7d0ae3"><span class="org-haskell-constructor">Red</span> <span class="org-haskell-definition">==</span> <span class="org-haskell-constructor">Blue</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:826:1-3: error: Data constructor not in scope: Red

&lt;interactive&gt;:826:8-11: error: Data constructor not in scope: Blue
</pre>


<p>
Good. More Haskell lore as we go. So we have a Haskell code version of
math&rsquo;s \(d\) <i>divides</i> \(n\). Let&rsquo;s move on.
</p>
</div>
</div>
<div id="outline-container-org9e9c835" class="outline-4">
<h4 id="org9e9c835">A <i>least divisor</i></h4>
<div class="outline-text-4" id="text-org9e9c835">
<p>
<font color = "#4715b3">
‚á≤ We define \(LD(n)\) as the least natural number <i>greater than \(1\)</i>
that divides \(n\), or the <i>least divisor</i> of \(n\).
</font>
</p>

<p>
Every number has at least one divisor greater than <i>unit</i> \(1\).<label id='fnr.12' for='fnr-in.12.8478366' class='margin-toggle sidenote-number'><sup class='numeral'>12</sup></label><input type='checkbox' id='fnr-in.12.8478366' class='margin-toggle'><span class='sidenote'><sup class='numeral'>12</sup>
Again, a prime number has exactly one divisor greater than \(1\), i.e.,
the prime number itself.
</span>
Therefore, every number \(n\) has a smallest, <i>least</i> divisor, \(LD(n)\),
in its set of divisors, even if that set has only one element. We will
leverage this fact to test a number for primeness. Read on.
</p>

<p>
Let&rsquo;s look at a <i>composite</i> number \(12\) with the set of divisors
\(\{2,3,4,6,12\}\). Here, \(LD(12) = 2\) and the <b>cardinality</b><label id='fnr.13' for='fnr-in.13.7457167' class='margin-toggle sidenote-number'><sup class='numeral'>13</sup></label><input type='checkbox' id='fnr-in.13.7457167' class='margin-toggle'><span class='sidenote'><sup class='numeral'>13</sup>
The <b>cardinality</b> of a set is the count of the unique elements
contained in the set.
</span> of
the set is \(5\), i.e., greater than \(1\). What about \(120\)? The divisor
set<label id='fnr.14' for='fnr-in.14.8147625' class='margin-toggle sidenote-number'><sup class='numeral'>14</sup></label><input type='checkbox' id='fnr-in.14.8147625' class='margin-toggle'><span class='sidenote'><sup class='numeral'>14</sup>
&#x2026;or the <i>factors</i> of \(120\).
</span> would be much larger
</p>

\begin{align*}
\{2,3,4,5,6,8,10,12,15,20,24,30,40,60,120\}
\end{align*}

<p>
and we can get it with this Haskell code<label id='fnr.15' for='fnr-in.15.4122366' class='margin-toggle sidenote-number'><sup class='numeral'>15</sup></label><input type='checkbox' id='fnr-in.15.4122366' class='margin-toggle'><span class='sidenote'><sup class='numeral'>15</sup>
This is the Haskell version of <b><a href="https://en.wikipedia.org/wiki/Set-builder_notation">set comprehension</a></b>. More
later.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgdf201f6"><span class="org-haskell-definition">divisors</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integer</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-type">Integer</span><span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">divisors</span> n <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>d <span class="org-haskell-operator">|</span> d <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>2<span class="org-haskell-operator">..</span>abs n<span class="org-rainbow-delimiters-depth-2">]</span>, abs n <span class="org-haskell-operator">`mod`</span> d <span class="org-haskell-operator">==</span> 0<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
testing
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org0fa2dbb"><span class="org-haskell-definition">divisors</span> 120
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:828:1-8: error:
    Variable not in scope: divisors :: t0 -&gt; t
</pre>


<p>
As with \(12\), we see a pattern where we start with a divisor that is
prime, then (if any) composite numbers follow.<label id='fnr.16' for='fnr-in.16.5888636' class='margin-toggle sidenote-number'><sup class='numeral'>16</sup></label><input type='checkbox' id='fnr-in.16.5888636' class='margin-toggle'><span class='sidenote'><sup class='numeral'>16</sup>
Let&rsquo;s not forget the <i>Fundamental Theorem of Arithmetic</i>,
i.e., that \(120\) can also be expressed as product of powers of those
first three primes.
</span> In both examples
notice that the square the \(LD(n)\), e.g., with \(120\) squaring \(2\) is
\(4\), is less than \(120\). Why is this germane?
</p>

<p>
Consider the composite number \(143\). Its divisors are two prime
numbers, \(11\) and \(13\). Now, \(11^2 = 121\), while \(13^2 = 169\), i.e.,
the square of the former, i.e., the \(LD(143)\), is less than
\(143\). Neat observation, but does this help us in testing a number for
primeness? Yes, and we&rsquo;ll find out why below.
</p>

<p>
<font color = "#4715b3">
‚á≤ Proposition
</p>
<ol class="org-ol">
<li>If \(n > 1\) then \(LD(n)\) is a prime number.</li>
<li>If \(n > 1\) and \(n\) is not a prime number, then \((LD(n))^2 \le n\)</li>
</ol>
<p>
</font>
</p>

<p>
The gist of these two implications will be turned into code that will
help test if a number is prime.
</p>

<p>
Why concentrate on the least divisor? The first part of our
proposition will anchor the fact that the least divisor is always a
prime. This will be necessary for when a number is analyzed for
primeness and no divisor less than the number itself has been
found. But we need to prove that least divisor is indeed prime. How?
We&rsquo;ll employ a proof method called <i>contradiction</i><label id='fnr.17' for='fnr-in.17.893959' class='margin-toggle sidenote-number'><sup class='numeral'>17</sup></label><input type='checkbox' id='fnr-in.17.893959' class='margin-toggle'><span class='sidenote'><sup class='numeral'>17</sup>
See <a href="https://en.wikipedia.org/wiki/Proof_by_contradiction">proof by contradiction</a>.
</span> where we
claim just the opposite of what we want to prove, then expose it as
not true. In this case, let&rsquo;s assume \(c = LD(n)\) and \(c\) is <i>not</i>
prime, a contradiction of our original statement. But if \(c\) is not
prime it must then be a composite number itself, e.g., \(c = a \cdot b\)
where \(1 \lt a \lt c\). But that would mean \(a\) now divides \(n\), and \(a\) is
smaller than \(c\) the supposed \(LD(n)\). Therefore, a \(LD(n)\) must be
prime.
</p>

<p>
Now, before attacking the second part, let&rsquo;s do an example.
</p>

<p>
<font color = "#0d3db3">
ùñüùï≠: Is \(599\) a prime?
</font>
</p>

<p>
If \(599\) is composite, then \(599 = d \cdot e\) with \(d,e \gt 1\). This implies
</p>

\begin{align*}
d &\le \sqrt{599} \quad or \\
e &\le \sqrt{599}
\end{align*}

<p>
because if both \(d\) and \(e\) were greater than \(\sqrt{599}\) (the
opposite of less than or equal to) that would make \(d \cdot e\) greater
than \(\sqrt{599} \cdot \sqrt{599} = 599\), which it can&rsquo;t be. So if \(599\)
is composite, it has a divisor between \(2\) and \(\lfloor \sqrt{599} \rfloor\)<label id='fnr.18' for='fnr-in.18.6902977' class='margin-toggle sidenote-number'><sup class='numeral'>18</sup></label><input type='checkbox' id='fnr-in.18.6902977' class='margin-toggle'><span class='sidenote'><sup class='numeral'>18</sup>
The <b>floor</b> (\(\lfloor\; \rfloor\)) of \(\sqrt{599}\)? First, get the square
root of \(599\), which is \(24.474476501040833\); so the <i>lowest</i> whole
number, the floor, would be \(24\). The \(\lceil\sqrt{599}\rceil\), or the <b>ceiling</b>
of the square root of \(599\) would be \(25\).
</span>
or \(24\).
</p>

<p>
At this point we can guess that to show \(599\) is prime, we need to
show it has no divisor  not a composite number. \(24^2 = 576\), the <i>floor</i> of
\(\sqrt{599}\), but \(25^2 = 625\) which is overshoot. We can restate the
second part of the proposition thusly
</p>

<p>
<font color = "#4715b3"> ‚á≤ Proposition <br>
Let \(n\) be a natural number. If \(n\) is <i>composite</i> then \(n\) has a
prime divisor between \(2\) and \(\lfloor\sqrt{n}\rfloor\). Thus, if \(n \gt 1\) and \(n\)
has <i>no</i> prime divisors between \(2\) and \(\lfloor\sqrt{n}\rfloor\), then \(n\) must be
prime.  </font>
</p>

<p>
which allows us to quit looking for a \(LD(n)\), i.e., some prime, long
before we get to \(599\). If we test this algorithmic proposition on
\(599\) we see that none of the primes between \(2\) and \(24\), namely the
set of primes \(\{2,3,5,7,11,13,17,19,23\}\) divides \(599\) evenly;
therefore, \(599\) is prime.
</p>

<p>
We now have our main tool for establishing primality, namely, \(LD(n)\)
proven. Let&rsquo;s put it into code. We&rsquo;ll break it into two parts
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org9f6b9d4"><span class="org-haskell-definition">ld</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integral</span> t <span class="org-haskell-operator">=&gt;</span> t <span class="org-haskell-operator">-&gt;</span> t
<span class="org-haskell-definition">ld</span> n <span class="org-haskell-operator">=</span> ldf 2 n
<span class="org-haskell-definition">ldf</span> k n <span class="org-haskell-operator">|</span> divides k n <span class="org-haskell-operator">=</span> k
        <span class="org-haskell-operator">|</span> k<span class="org-haskell-operator">^</span>2 <span class="org-haskell-operator">&gt;</span> n <span class="org-haskell-operator">=</span> n
        <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> ldf <span class="org-rainbow-delimiters-depth-1">(</span>k<span class="org-haskell-operator">+</span>1<span class="org-rainbow-delimiters-depth-1">)</span> n
</pre>
</div>

<p>
<code>ld</code> is just a wrapper to feed our number in question into <code>ldf</code>, the
&ldquo;least divisor function&rdquo; which will do the actual work. What we see
with <code>ldf</code> is Haskell&rsquo;s <b>equation guarding</b>, which allows us to set up
test <b>cases</b>. <code>ldf</code> first tries <code>divides</code> (which yields either <code>True</code>
or <code>False</code>) on the incoming number argument <code>n</code> using the argument
<code>k</code>. We see <code>ldf</code> begins with the lowest prime \(2\) for <code>k</code>. So if \(2
\mid n\) then we&rsquo;re through, the \(LD(n) = k\). But if it is not then we
move on to the next <i>case</i>, namely, Is <code>k</code> squared greater than
<code>n</code>?<label id='fnr.19' for='fnr-in.19.3978722' class='margin-toggle sidenote-number'><sup class='numeral'>19</sup></label><input type='checkbox' id='fnr-in.19.3978722' class='margin-toggle'><span class='sidenote'><sup class='numeral'>19</sup>
This is the second part of \(LD(n)\) Proposition, i.e., we&rsquo;ve
flipped the \((LD(n))^2 \le n\). <code>ld</code> looks for a prime divisor of \(n\) by
checking \(k \mid n\) for all \(k\) with \(2 \le k \le \sqrt{n}\). But isn&rsquo;t a
\(LD(n)\) supposed to be prime? We will improve on <code>ld</code> so it doesn&rsquo;t
waste time checking non-prime \(k\) within \(2 \le k \le \sqrt{n}\).
</span> Again, this yields a <code>True</code> or <code>False</code>. If <code>True</code>, then
<code>n</code> is the least divisor. But if this second test case also fails, we
go onto the third, which is not a normal test case, but a hardwired
<code>True</code>, i.e., we&rsquo;re going with this case&#x2014;because there are no other
possible situations. What&rsquo;s unique about this last case is that it
simply calls itself, but with <code>k</code> incremented by \(1\). In other words,
we have a repeating mechanism whereby we can march up through the
whole numbers one after the other testing each. This is <b>recursion</b>,
and we&rsquo;ll soon be exploring it in depth. But for now just accept that
<code>ldf</code> is calling itself, driving inside itself, so to speak, to try
another time.
</p>

<p>
Let&rsquo;s investigate the number \(5\) and how <code>ldf</code> handles it
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd49c6e7"><span class="org-haskell-definition">ld</span> 5
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:830:1-2: error:
    Variable not in scope: ld :: t0 -&gt; t
    Suggested fix: Perhaps use ‚Äòid‚Äô (imported from Prelude)
</pre>


<p>
How did <code>ld</code> find this? In the first iteration, the first test case,
\(2 \mid 5\), fails, followed by the second test case, <code>2^2 &gt; 5</code>, which
is also <code>False</code> since \(4 \lt 5\). Hence, recursion ensues with <code>ldf 3
5</code>. On the first test case <code>divides 3 5</code> also fails, but then the
second test case, <code>3^2 &gt; 5</code> is <code>True</code>; and so we know \(5\) is indeed
the least divisor. And so we have turned our Proposition theorems into
an algorithm and working code! Let&rsquo;s see a more general
(non-abbreviated) explanation of <i>equation guarding</i>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org1def633"><span class="org-haskell-definition">foo</span> t <span class="org-haskell-operator">|</span> condition_1 <span class="org-haskell-operator">=</span> body_1
<span class="org-haskell-definition">foo</span> t <span class="org-haskell-operator">|</span> condition_2 <span class="org-haskell-operator">=</span> body_2
<span class="org-haskell-definition">foo</span> t <span class="org-haskell-operator">|</span> condition_3 <span class="org-haskell-operator">=</span> body_3
<span class="org-haskell-definition">foo</span> t <span class="org-haskell-operator">|</span>             <span class="org-haskell-operator">=</span> body_4
</pre>
</div>

<p>
Now using our <code>ld</code> function, let&rsquo;s define our first version of a <i>test
for primes</i>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org06d8357"><span class="org-haskell-definition">prime0</span> n <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">&lt;</span> 1 <span class="org-haskell-operator">=</span> error <span class="org-string">"Not a positive integer"</span>
         <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">==</span> 1 <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
         <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> ld n <span class="org-haskell-operator">==</span> n
</pre>
</div>

<p>
When we compile this, our Haskell REPL complains that we didn&rsquo;t
provide a type signature for <code>prime0</code> and then suggests one&#x2014;or we
can simply ask
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org908c1c6"><span class="org-haskell-constructor">:</span>t prime0
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-6: error: Variable not in scope: prime0
</pre>


<p>
Let&rsquo;s add it
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org4fa171c"><span class="org-haskell-definition">prime0</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integral</span> a <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Bool</span>
<span class="org-haskell-definition">prime0</span> n <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">&lt;</span> 1 <span class="org-haskell-operator">=</span> error <span class="org-string">"Not a positive integer"</span>
         <span class="org-haskell-operator">|</span> n <span class="org-haskell-operator">==</span> 1 <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>
         <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> ld n <span class="org-haskell-operator">==</span> n
</pre>
</div>






<div class="org-src-container">
<pre class="src src-haskell" id="org13b1d79"><span class="org-haskell-definition">reduce</span> <span class="org-haskell-operator">::</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
<span class="org-haskell-pragma">{-# SPECIALISE reduce :: Integer -&gt; Integer -&gt; Rational #-}</span>
<span class="org-haskell-definition">reduce</span> <span class="org-haskell-keyword">_</span> 0              <span class="org-haskell-operator">=</span>  ratioZeroDenominatorError
<span class="org-haskell-definition">reduce</span> x y              <span class="org-haskell-operator">=</span>  <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:%</span> <span class="org-rainbow-delimiters-depth-1">(</span>y <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span>
                           <span class="org-haskell-keyword">where</span> d <span class="org-haskell-operator">=</span> gcd x y

x <span class="org-haskell-definition">%</span> y                   <span class="org-haskell-operator">=</span>  reduce <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">*</span> signum y<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>abs y<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-haskell-definition">numerator</span>   <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-constructor">:%</span> <span class="org-haskell-keyword">_</span><span class="org-rainbow-delimiters-depth-1">)</span>    <span class="org-haskell-operator">=</span>  x
<span class="org-haskell-definition">denominator</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">:%</span> y<span class="org-rainbow-delimiters-depth-1">)</span>    <span class="org-haskell-operator">=</span>  y
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell" id="org491c8cd"><span class="org-haskell-definition">gcd</span>             <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">gcd</span> x y         <span class="org-haskell-operator">=</span>  gcd' <span class="org-rainbow-delimiters-depth-1">(</span>abs x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>abs y<span class="org-rainbow-delimiters-depth-1">)</span>
                   <span class="org-haskell-keyword">where</span> gcd' a 0  <span class="org-haskell-operator">=</span>  a
                         gcd' a b  <span class="org-haskell-operator">=</span>  gcd' b <span class="org-rainbow-delimiters-depth-1">(</span>a <span class="org-haskell-operator">`rem`</span> b<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org60e9411"><span class="org-haskell-definition">lcm</span>             <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a
<span class="org-haskell-definition">lcm</span> <span class="org-haskell-keyword">_</span> 0         <span class="org-haskell-operator">=</span>  0
<span class="org-haskell-definition">lcm</span> 0 <span class="org-haskell-keyword">_</span>         <span class="org-haskell-operator">=</span>  0
<span class="org-haskell-definition">lcm</span> x y         <span class="org-haskell-operator">=</span>  abs <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">`quot`</span> <span class="org-rainbow-delimiters-depth-3">(</span>gcd x y<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">*</span> y<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
‚•§ <b>Exclusive or</b>
</p>

<p>
An <b>exclusive or</b> is the negation of an implication
</p>

<table id="orgac01944" border="2" rules="all" frame="border">


<colgroup>
<col  class="org-center">

<col  class="org-center">

<col  class="org-center">

<col  class="org-center">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">P</th>
<th scope="col" class="org-center">Q</th>
<th scope="col" class="org-center">P \(\nleftrightarrow Q\)</th>
<th scope="col" class="org-center">P \(\iff Q\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-center">t</td>
<td class="org-center">t</td>
<td class="org-center">f</td>
<td class="org-center">t</td>
</tr>

<tr>
<td class="org-center">t</td>
<td class="org-center">f</td>
<td class="org-center">t</td>
<td class="org-center">f</td>
</tr>

<tr>
<td class="org-center">f</td>
<td class="org-center">t</td>
<td class="org-center">t</td>
<td class="org-center">f</td>
</tr>

<tr>
<td class="org-center">f</td>
<td class="org-center">f</td>
<td class="org-center">f</td>
<td class="org-center">t</td>
</tr>
</tbody>
</table>
<p>
<br>
</p>

<p>
This shows that <b>exclusive or</b> is indeed the negation of <b>if and only
if equivalence</b>. Only if the arguments \(P\) and \(Q\) have different
truth values is the <b>exclusive or</b> true.
</p>

<p>
For example, <i>Did \(A\) (exclusive) or \(B\) win?</i> So &ldquo;win&rdquo; as in true;
hence, both cannot have won, nor can both have lost.
</p>




<p>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="./images/by-nc-sa.png" width="125px" style="padding: 100px 0px 0px 0px" alt="License-disense"</a>
</p>
</div>
</div>
</div>
</section>
</article>
</body>
</html>
