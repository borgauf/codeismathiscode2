# # -*- mode: org -*- coding: utf-8 -*-
#+TITLE: 
#+AUTHOR:
#+EMAIL: 
#+DATE: 
#+LANGUAGE:  en
# #+INFOJS_OPT: view:showall ltoc:t mouse:underline
#+HTML_HEAD: <link rel="stylesheet" href="./tufte.css" type="text/css">
#+HTML_HEAD: <link rel="stylesheet" href="./ox-tufte.css" type="text/css">
#+HTML_HEAD_EXTRA: <style>
#+HTML_HEAD_EXTRA: article > div.org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: article > section .org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: div.org-src-container > pre { clear: none; }
#+HTML_HEAD_EXTRA: pre.example {clear: none; }
#+HTML_HEAD_EXTRA: </style>
#+INCLUDE: "./header.org" :minlevel 1
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_FILE_NAME: PrologLearnPrologNow1.html
#+OPTIONS: H:15 num:nil toc:nil \n:nil @:t ::t |:t _:{} *:t ^:{} prop:nil
#+OPTIONS: tex:t
#+OPTIONS: html-postamble:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]
# Setup tikz package for both LaTeX and HTML export:
# #+LATEX_HEADER: \usepackqqqage{tikz}
# #+LATEX_HEADER: \usepackage{commath}
# #+LaTeX_HEADER: \usepackage{pgfplots}
# #+LaTeX_HEADER: \usepackage{sansmath}
# #+LaTeX_HEADER: \usepackage{mathtools}
# #+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#
#+PROPERTY: header-args:latex+ :exports results :fit yes
#
#+STARTUP: showall
#+STARTUP: align
#+STARTUP: indent
#+STARTUP: shrink
# This makes MathJax/LaTeX appear in buffer (UTF-8)
#+STARTUP: latexpreview
#+STARTUP: entitiespretty
# #+STARTUP: logdrawer
# This makes pictures appear in buffer
#+STARTUP: inlineimages
#+STARTUP: fnadjust
# #+OPTIONS: html-style:nil
#+html_head_extra: <style> .title { display: none; } </style>
#+html_head_extra: <style> caption.t-bottom { caption-side: bottom; } </style>

* Logical reasoning 1

**  Bibliography :noexport:
:RESOURCES:
- [[bibliography:~/Dropbox/org/biblio/ref.bib][Bibliography]]
:END:

** Not exported :noexport:

#+name: module
#+begin_src haskell :eval never :exports code :tangle ./src/lrafc1.hs :noweb yes
{-# LANGUAGE FlexibleInstances #-}
{-# OPTIONS_GHC -Wno-type-defaults #-}
module LRAFC1 where

infix 1 ==>

(==>) :: Bool -> Bool -> Bool
x ==> y = (not x) || y

infix 1 <=>

(<=>) :: Bool -> Bool -> Bool
x <=> y = x == y 

infixr 2 <+>

(<+>) :: Bool -> Bool -> Bool
x <+> y = x /= y 

testp :: Bool  
testp = True
testq :: Bool  
testq = False

formula1 :: Bool  
formula1 = (not testp) && (testp ==> testq) <=> not (testq && (not testp))

formula2 :: Bool -> Bool -> Bool  
formula2 p q = ((not p) && (p ==> q) <=> not (q && (not p)))

valid1 :: (Bool -> Bool) -> Bool
valid1 bf =  (bf True) && (bf False)

excluded_middle :: Bool -> Bool
excluded_middle p = p || not p

valid2 :: (Bool -> Bool -> Bool)  -> Bool
valid2 bf =   (bf True  True)  
           && (bf True  False) 
           && (bf False True) 
           && (bf False False)

form1 :: Bool -> Bool -> Bool  
form1 p q = p ==> (q ==> p)

form2 :: Bool -> Bool -> Bool  
form2 p q = (p ==> q) ==> p

valid3 :: (Bool -> Bool -> Bool -> Bool) -> Bool
valid3 bf = and [ bf p q r | p <- [True,False], 
                             q <- [True,False], 
                             r <- [True,False]] 

valid4 :: (Bool -> Bool -> Bool -> Bool -> Bool) -> Bool
valid4 bf = and [ bf p q r s | p <- [True,False], 
                               q <- [True,False], 
                               r <- [True,False], 
                               s <- [True,False]] 

logEquiv1 ::  (Bool -> Bool) -> (Bool -> Bool) -> Bool
logEquiv1 bf1 bf2 =  
    (bf1 True  <=> bf2 True) && (bf1 False <=> bf2 False) 

logEquiv2 :: (Bool -> Bool -> Bool) -> 
                    (Bool -> Bool -> Bool) -> Bool
logEquiv2 bf1 bf2 = 
  and [(bf1 p q) <=> (bf2 p q)  |  p <- [True,False], 
                                   q <- [True,False]]

logEquiv3 :: (Bool -> Bool -> Bool -> Bool) ->
                 (Bool -> Bool -> Bool -> Bool) -> Bool
logEquiv3 bf1 bf2 = 
  and [(bf1 p q r) <=> (bf2 p q r) |  p <- [True,False], 
                                      q <- [True,False], 
                                      r <- [True,False]]

formula3 :: p1 -> p2 -> p1
formula3 p _q = p -- formula3 p _ = p

formula4 :: Bool -> Bool -> Bool
formula4 p q = (p <+> q) <+> q

formula5 :: Bool -> Bool -> Bool  
formula5 p q = p <=> ((p <+> q) <+> q)

class TF p where 
  valid :: p -> Bool
  lequiv :: p -> p -> Bool

instance TF Bool
 where
  valid  = id
  lequiv f g = f == g

instance TF p => TF (Bool -> p)
 where
  valid f = valid (f True) && valid (f False)
  lequiv f g = (f True) `lequiv` (g True)
               && (f False) `lequiv` (g False)

test1, test2a, test2b, test3a, test3b, test4a, test4b, test4c,
  test5a, test5b, test6a, test6b, test7a, test7b, test8a,
  test8b, test9a, test9b :: Bool
test1  = lequiv id (\ p -> not (not p))
test2a = lequiv id (\ p -> p && p) 
test2b = lequiv id (\ p -> p || p) 
test3a = lequiv (\ p q -> p ==> q) (\ p q -> not p || q)
test3b = lequiv (\ p q -> not (p ==> q)) (\ p q -> p && not q)
test4a = lequiv (\ p q -> not p ==> not q) (\ p q -> q ==> p)
test4b = lequiv (\ p q -> p ==> not q) (\ p q -> q ==> not p)
test4c = lequiv (\ p q -> not p ==> q) (\ p q -> not q ==> p)
test5a = lequiv (\ p q -> p <=> q) 
                (\ p q -> (p ==> q) && (q ==> p))
test5b = lequiv (\ p q -> p <=> q) 
                (\ p q -> (p && q) || (not p && not q))
test6a = lequiv (\ p q -> p && q) (\ p q -> q && p)
test6b = lequiv (\ p q -> p || q) (\ p q -> q || p)
test7a = lequiv (\ p q -> not (p && q)) 
                (\ p q -> not p || not q)
test7b = lequiv (\ p q -> not (p || q)) 
                (\ p q -> not p && not q)
test8a = lequiv (\ p q r -> p && (q && r)) 
                (\ p q r -> (p && q) && r)
test8b = lequiv (\ p q r -> p || (q || r)) 
                (\ p q r -> (p || q) || r)
test9a = lequiv (\ p q r -> p && (q || r)) 
                (\ p q r -> (p && q) || (p && r))
test9b = lequiv (\ p q r ->  p || (q && r)) 
                (\ p q r -> (p || q) && (p || r))

square1 :: Integer -> Integer
square1 x = x^2 

square2 :: Integer -> Integer 
square2 = \ x -> x^2

m1 :: Integer -> Integer -> Integer 
m1 = \ x -> \ y -> x*y

m2 :: Integer -> Integer -> Integer 
m2 = \ x y -> x*y

solveQdr :: (Float,Float,Float) -> (Float,Float) 
solveQdr =  \ (a,b,c) -> if a == 0 then error "not quadratic"
                         else let d = b^2 - 4*a*c in 
                         if d < 0 then error "no real solutions"
                         else 
                           ((- b + sqrt d) / 2*a,
                            (- b - sqrt d) / 2*a)

every, some :: [a] -> (a -> Bool) -> Bool
every xs p = all p xs 
some  xs p = any p xs



#+end_src


* Basic prolog source block
  #+NAME: basic-test
  #+BEGIN_SRC prolog :results verbatim
  :- format('Hello, ~a.', org_mode).
  #+END_SRC

  #+RESULTS: basic-test
  : Hello, org_mode.

 

 
* Source block with goal
  #+NAME: goal-test
  #+BEGIN_SRC prolog :goal main :results verbatim
main :- write('Hello, world!').
  #+END_SRC

  #+RESULTS: goal-test
  : Hello, world!
 

  
* Simple running session
  #+NAME: session-test
  #+HEADER: :session *prolog-1*
  #+HEADER: :goal fourtyone(A)
  #+HEADER: :results verbatim
  #+BEGIN_SRC prolog
    fourtyone(A) :- A is 41.
  #+END_SRC

  #+RESULTS: session-test
  : A = 41.


This requires a package to work, i.e., doesn't work as is...
  
#+BEGIN_SRC prolog :results output :goal fact(7,F)
fact(0,1).
fact(N,F):-
    N #> 0,
    F #> 0,
    N1 #= N-1,
    F #= N*F1,
    fact(N1,F1).
#+END_SRC 

#+RESULTS:




* Calling predicate from session
  #+NAME: other-predicate-test
  #+HEADER: :goal answer(A)
  #+HEADER: :session *prolog-1*
  #+BEGIN_SRC prolog
    answer(C) :-
        fourtyone(B),
        C is B+1.
  #+END_SRC

  #+RESULTS: other-predicate-test
  : A = 42.

  #+RESULTS:



* Test interaction with other blocks
  #+NAME: f
  #+BEGIN_SRC elisp :results vector
  '(1 2 3)
  #+END_SRC

  #+RESULTS: f
  | 1 | 2 | 3 |


  #+NAME: interaction-test
  #+HEADER: :var a=f()
  #+HEADER: :var b=0
  #+HEADER: :goal main(A)
  #+HEADER: :session *prolog-1*
  #+BEGIN_SRC prolog
  main(B) :- recorded(a, A), recorded(b, C), append([C], A, B).
  #+END_SRC

  #+RESULTS: interaction-test
  | A = [0 | 1 | 2 | 3]. |


  #+name: 132a4294-16c9-4132-97aa-5fa43c3c8bc2
#+HEADER: :session *prolog-1*
#+HEADER: :goal eqls(A,B)
#+begin_src prolog :exports both :results verbatim
eqls(A,B) := kill(shoot(gun),Y) = kill(X,stab(knife)).
#+end_src

#+RESULTS: 132a4294-16c9-4132-97aa-5fa43c3c8bc2
: ERROR: Unknown procedure: eqls/2 (DWIM could not correct goal)
: ^  Exception: (4) setup_call_cleanup('$toplevel':notrace(call_repl_loop_hook(begin, 0)), '$toplevel':'$query_loop'(0), '$toplevel':notrace(call_repl_loop_hook(end, 0))) ? ?-

#+name: 21903f70-70e6-4274-b379-362f505a990d
#+HEADER: :session *prolog-1*
#+begin_src prolog :exports both :results output
likes(george, swimming).
likes(susie, tennis).
likes(susie, swimming).
likes(mary, X) :- likes(susie, X), likes(george, X).
#+end_src

#+RESULTS: 21903f70-70e6-4274-b379-362f505a990d
: |: |: |: |:
: true.

#+name: c7adfeff-b292-4543-a5cf-4a58808b9eba
#+HEADER: :session *prolog-1*
#+begin_src prolog :results output :exports both
?- likes(mary, X).
#+end_src

#+RESULTS: c7adfeff-b292-4543-a5cf-4a58808b9eba
: Warning: user://2:17:
: Warning:    Singleton variables: [X]
: |:
: true.


#+name: 0c1f6bcc-0664-41bb-ba55-3be491bec55e
#+HEADER: :session *prolog-1*
#+HEADER: :goal ml(X)
#+begin_src prolog :exports both :results verbatim
ml(X) :- likes(mary,X).
#+end_src

#+RESULTS: 0c1f6bcc-0664-41bb-ba55-3be491bec55e
: X = swimming.



#+name: d86cee0b-f33f-4804-9b6f-6393d0b0de2b
#+HEADER: :session *prolog-1*
#+HEADER: :goal
#+begin_src prolog :exports both :results verbatim
?- =(mia,mia).
#+end_src

#+RESULTS: d86cee0b-f33f-4804-9b6f-6393d0b0de2b
: |:
: true.

#+NAME: session-test
  #+HEADER: :session *prolog-1*
  #+HEADER: :goal fourtyone(A)
  #+HEADER: :results verbatim
  #+BEGIN_SRC prolog
    fourtyone(A) :- A is 41.
  #+END_SRC

#+name: 4272891e-51ed-4099-8ebf-68766425135d
#+HEADER: :session *prolog-1*
# #+HEADER: :goal vrt(X,Y,Z)
#+begin_src prolog :exports both :results verbatim
vrt(X,Y,Z) := vertical(line(point(X,Y),point(X,Z))).
% horizontal(line(point(X,Y),point(Z,Y))).
#+end_src

#+RESULTS:


Given this knowledge base

#+name: bd64f72b-546f-4e16-b849-42c3683a37b5
#+HEADER: :session *prolog-1*
#+begin_src prolog :results output :exports both
f(a).
f(b).
g(a).
g(b).
h(b).
k(X) :- f(X),g(X),h(X).
#+end_src

#+RESULTS: bd64f72b-546f-4e16-b849-42c3683a37b5
: |: |: |: |: |: |:
: true.

#+name: 61efb1c2-3b69-4a24-9652-5f2f2505673c
#+HEADER: :session *prolog-1*
#+begin_src prolog :exports both :results output
?- k(X).
#+end_src

#+RESULTS: 61efb1c2-3b69-4a24-9652-5f2f2505673c
: Warning: user://11:98:
: Warning:    Singleton variables: [X]
: |:
: true.

we can then

#+name: 8b6cbad0-3de2-4ec4-a3f9-5bd536b0cc4b
#+HEADER: :session *prolog-1*
#+HEADER: :goal k1(X)
#+begin_src prolog :exports both :results output
k1(X) :- k(X).
#+end_src

#+RESULTS: 8b6cbad0-3de2-4ec4-a3f9-5bd536b0cc4b
: X = b.


#+name: e1bc9d21-c8e3-4512-83e6-36b1e4489358
#+HEADER: :session *prolog-1*
#+HEADER: :goal
#+begin_src prolog :exports both :results verbatim
?- =(mia, mia).
#+end_src

#+RESULTS: e1bc9d21-c8e3-4512-83e6-36b1e4489358
: |:
: true.

#+name: a03d7ae6-1b78-46bc-96b4-30d2877f2b85
#+HEADER: :session *prolog-1*
#+HEADER: :goal
#+begin_src prolog :exports both :results verbatim
loves(vincent,mia).
loves(marcellus,mia).
jealous(X,Y) :- loves(X,Z),loves(Y,Z).
#+end_src

#+RESULTS: a03d7ae6-1b78-46bc-96b4-30d2877f2b85
: |: |: |:
: true.

#+name: 1ca93572-4439-4864-8bd2-a9bcc87196be
#+HEADER: :session *prolog-1*
#+HEADER: :goal j(X,Y)
#+begin_src prolog :exports both :results output
j(X,Y) :- jealous(X,Y).
#+end_src

#+RESULTS: 1ca93572-4439-4864-8bd2-a9bcc87196be
: X = Y, Y = vincent.

#+name: c9da4dfd-e000-4a20-af2f-be20250127b6
#+HEADER: :session *prolog-1*
#+HEADER: :goal
#+begin_src prolog :exports both :results verbatim
wizard(harry).
house_elf(dobby).
witch(hermione).
witch('McGonagall').
witch(rita_skeeter).
magic(X) :- house_elf(X).
magic(X) :- wizard(X).
magic(X) :- witch(X).
#+end_src

#+RESULTS: c9da4dfd-e000-4a20-af2f-be20250127b6
#+begin_example
true.
#+end_example

#+name: 5778b9ae-b713-4370-970c-03ead359bd40
#+HEADER: :session *prolog-1*
#+HEADER: :goal wh(A)
#+begin_src prolog :exports both :results verbatim
wh(A) :- wizard(harry).
#+end_src

#+RESULTS: 5778b9ae-b713-4370-970c-03ead359bd40
: true.

#+name: cc516669-d441-4e8b-9f49-1398118882ea
#+HEADER: :session *prolog-1*
#+HEADER: :goal wr(A)
#+begin_src prolog :exports both :results verbatim
wr(A) :- wizard(ron).
#+end_src

#+RESULTS: cc516669-d441-4e8b-9f49-1398118882ea
: false.

#+name: 34a4f59f-4d92-449a-9f1f-9ee60a34af03
#+HEADER: :session *prolog-1*
#+HEADER: :goal mmg(A)
#+begin_src prolog :exports both :results verbatim
mmg(A) :- magic('McGonagall').
#+end_src

#+RESULTS: 34a4f59f-4d92-449a-9f1f-9ee60a34af03
: true.




#+tblname: timings-table
| size |    time |
|------+---------|
|   50 |   0.063 |
|  100 |   0.361 |
|  200 |   1.995 |
|  400 |  14.659 |
|  800 | 123.244 |

#+name: plotting_2
#+begin_src R :var timings=timings-table :file "timings.svg" :exports results :async
library(ggplot2)
ggplot(data = timings) +
  geom_point(mapping = aes(x = size, y = time)) +
  stat_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, aes(x = size, y = time)) +
  theme(plot.background = element_blank())
#+end_src

#+RESULTS: plotting_2
: eb419c6e81d20a2d5a100a137e230e99
