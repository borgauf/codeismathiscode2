# # -*- mode: org -*- coding: utf-8 -*-
#+TITLE: 
#+AUTHOR:
#+EMAIL: 
#+DATE: 
#+LANGUAGE:  en
# #+INFOJS_OPT: view:showall ltoc:t mouse:underline
#+HTML_HEAD: <link rel="stylesheet" href="./tufte.css" type="text/css">
#+HTML_HEAD: <link rel="stylesheet" href=".//ox-tufte.css" type="text/css">
#+HTML_HEAD_EXTRA: <style>
#+HTML_HEAD_EXTRA: article > div.org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: article > section .org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: div.org-src-container > pre { clear: none; }
#+HTML_HEAD_EXTRA: pre.example {clear: none; }
#+HTML_HEAD_EXTRA: </style>
#+INCLUDE: "./header.org" :minlevel 1
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_FILE_NAME: LittleSchemer3.html
#+OPTIONS: H:15 num:nil toc:nil \n:nil @:t ::t |:t _:{} *:t ^:{} prop:nil
#+OPTIONS: tex:t
#+OPTIONS: html-postamble:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]
# Setup tikz package for both LaTeX and HTML export:
#+LATEX_HEADER: \usepackqqqage{tikz}
#+LATEX_HEADER: \usepackage{commath}
#+LaTeX_HEADER: \usepackage{pgfplots}
#+LaTeX_HEADER: \usepackage{sansmath}
#+LaTeX_HEADER: \usepackage{mathtools}
#+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#
#+PROPERTY: header-args:latex+ :exports results :fit yes
#
#+STARTUP: showall
#+STARTUP: align
#+STARTUP: indent
#+STARTUP: shrink
# This makes MathJax/LaTeX appear in buffer (UTF-8)
#+STARTUP: entitiespretty
# #+STARTUP: logdrawer # This makes pictures appear in buffer
#+STARTUP: inlineimages
#+STARTUP: fnadjust
# #+OPTIONS: html-style:nil
#+html_head_extra: <style> .title { display: none; } </style>
#+html_head_extra: <style> caption.t-bottom { caption-side: bottom; } </style>

* Little Schemer 3

#+begin_figure
#+CAPTION: The Little Schemer putting together a combinator.
[[file:images/LittleSchemerElephant1.png]]
#+end_figure


** Bibliography :noexport:
:PROPERTIES:
:header-args: :dir "/home/galaxybeing/Dropbox/org/codeismathiscode2"
:END:
:RESOURCES:
- [[bibliography:~/Dropbox/org/biblio/ref.bib][Bibliography]]
- [[cite:&friedman1995little]]
:END:


* 

** The math behind the if-then-else

#+name: c650cd72-a6db-4de1-8f09-5c04d109a207
#+begin_src scheme :session *littleschemer* :results verbatim :exports code
(define (mylogictest n) (or (and (> n 12) 1) (and (<= n 12) 0)))
#+end_src





Who "checks" if the base case has arrived?


\\

** A /linked/ list is...

In the world of computer science *[[https://en.wikipedia.org/wiki/Data_structure][data structures]]*, a list is more
commonly thought of as a *linked list*. For ~(cons 42 (cons 69 (cons
613 '()))~ or ~(42 . (69 . (613 . '())))~ we see the three individual
/cons cells/ in the image below

#+begin_figure
#+CAPTION: A linked list representation of the list ~(42 69 613)~.
[[file:images/Cons-cells.png]]
#+end_figure

and a handy ascii representation would be

#+begin_example
*---->*---->*---->NIL
|     |     |
v     v     v
42    69   613
#+end_example

In the Lisp-Scheme family we're not so concerned that this is a
/linked/ list, since the actual internal structure of a list doesn't
require any knowledge of *[[https://en.wikipedia.org/wiki/Pointer_(computer_programming)][pointers]]* as does a language like *[[https://en.wikipedia.org/wiki/C_(programming_language)][C]]*. For
C/C++ programmers these diagrams say that a location in memory for a
cons cell with two "compartments" contains a pointer in the first
compartment to, e.g., ~42~, while the other compartment contains a
pointer to the memory address of the next, the adjoining cons
cell. But again, in Scheme we will never deal directly with actual
pointer memory addresses. Nonetheless, with our pointer-based diagrams
we have a train-looking thing with a ~NIL~ or ~'()~ as the
caboose. What would just ~(cons 'b 'c)~ or ~(b . c)~ look like
diagrammatically? It would in fact be a single cons cell

#+begin_figure
#+CAPTION: Single cons cell for ~(cons 'b 'c)~.
[[file:images/bc.png]]
#+end_figure

Here we see the right and left compartments named, the left is called
the ~car~ and the right is called the ~cdr~ compartment. These names
come from many decades ago when Lisp was first developed and deployed
on a mainframe. But they are also Scheme primitive operators like
~cons~. So if ~(cons 'b 'c)~ produces ~(b . c)~ then

#+name: 22c36165-15a5-4220-a2d1-3705302f39e0
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car (cons 'b  'c))
#+end_src

#+RESULTS: 22c36165-15a5-4220-a2d1-3705302f39e0
: b

and

#+name: 5d40cc99-3aef-4090-a5fa-36a392c7775c
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr (cons 'b 'c))
#+end_src

#+RESULTS: 5d40cc99-3aef-4090-a5fa-36a392c7775c
: c

And so they are operators that surgically remove the *head* and the
*tail* of a cons cell. Let's try this again with ~(cons 42 (cons 69 (cons 613 '())))~ or
sugared ~(42 69 613)~

#+begin_figure
#+CAPTION: A linked list representation of the list ~(42 69 613)~ with ~car~ and ~cdr~.
[[file:images/Cons-cells2.png]]
#+end_figure

#+name: 9a5a45ad-86b9-4b5f-8f22-0f853698d9bb
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car '(42 69 613))
#+end_src

#+RESULTS: 9a5a45ad-86b9-4b5f-8f22-0f853698d9bb
: 42

and

#+name: a6c48364-ab5b-4e75-97a0-af4b080056db
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr '(42 69 613))
#+end_src

#+RESULTS: a6c48364-ab5b-4e75-97a0-af4b080056db
: (69 613)

Did this surprised you? Again, ~car~ returns the contents of the first
element of the list, i.e., the *head* of the list; and ~cdr~ returns
the *tail* or the /rest of the list/. Let's look at ~cdr~ without
syntactic sugar

#+name: f3c4f7ce-7668-4d2f-bb58-6bc7e9418f29
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr (cons 42 (cons 69 (cons 613 '()))))
#+end_src

#+RESULTS: f3c4f7ce-7668-4d2f-bb58-6bc7e9418f29
: (69 613)

As we see, Scheme throws back in the sugar, but what happened is the
tail of ~(cons 42 (cons 69 (cons 613 '())))~ was returned, i.e.,
~(cons 69 (cons 613 '()))~ $\rightarrow$ ~(69 613)~. Let's now reverse this

#+name: 2fc9509a-c5de-4455-aea2-b876b7e77e9d
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cons 42 (cdr '(42 69 613)))
#+end_src

#+RESULTS: 2fc9509a-c5de-4455-aea2-b876b7e77e9d
: (42 69 613)

Here's another example

#+name: 4772d381-118a-4c3d-9704-3d70494d5949
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(car '(((five is a nice number) 5) but so is six))
#+end_src

#+RESULTS: 4772d381-118a-4c3d-9704-3d70494d5949
: ((five is a nice number) 5)

and

#+name: 95063d6e-c9c5-450b-9d69-d0d110ae5242
#+begin_src scheme :session *littleschemer* :results verbatim :exports both
(cdr '(((five is a nice number) 5) but so is six))
#+end_src

#+RESULTS: 95063d6e-c9c5-450b-9d69-d0d110ae5242
: (but so is six)

⌜ \\
@@html:<font color = "#4715b3">@@ ⇲ Try to glue ~((five is a nice
number) 5)~ and ~(but so is six)~ back together with ~cons~
@@html:</font>@@ \\
⌟




So is ~(b . c)~ a true, /proper/ list? No, it is called an /improper/
list or a /dotted list/ since we have just a single cons cell with ~2~
in the /cdr/ position. The final /cdr/ position of the last cons cell
must be consed with the ~nil~ or the /empty set/. By this definition
~(cons 1 '())~ is a proper list, but something like ~(a b c . d)~ has
as the last /cdr/ ~d~ which is not ~nil~, i.e., ~'()~.


#+name: 9b2d2b89-3eae-46c7-8cfa-0cc8b0a8ef01
#+begin_src scheme :session *littleschemer* :results verbatim
(cons 1 '())
#+end_src

#+RESULTS: 9b2d2b89-3eae-46c7-8cfa-0cc8b0a8ef01
: (1)

#+name: 1850bca2-9e37-4ce1-8641-bcef322e4e84
#+begin_src scheme :session *littleschemer* :results verbatim
(cons 1 (cons 2 (cons 3 '())))
#+end_src

#+RESULTS: 1850bca2-9e37-4ce1-8641-bcef322e4e84
: (1 2 3)





#+name: 4232bfa8-5cd3-417a-a6d0-5b62aace9e11
#+begin_src scheme :session *littleschemer* :results verbatim
(list 1 2 3)
#+end_src

#+RESULTS: 4232bfa8-5cd3-417a-a6d0-5b62aace9e11
: (1 2 3)



#+INCLUDE: "./footer.org" :minlevel 1

* Footnotes

[fn:1] *CPU*: central processing unit, the calculation "brains" of a
computer.

[fn:2] This important quality of a function was touched on in the
preface.

[fn:3] In pre-algebra a function is typically graphed with the
horizontal axis representing the /independent variable/ and the
vertical axis representing the /dependent variable/. \\
[[file:images/Polynomialdeg2.png]] \\
In this idea of the function, y is the /dependent variable/ and x is
the /independent variable/.

[fn:4] What follows was taken from [[https://www.reddit.com/r/mathematics/comments/wseco9/is_function_an_expression/][this]] reddit discussion.

[fn:5] We will use *sexp* the abbreviation for S-expression.

[fn:6] A set of elements is *closed* under a binary operation if by
applying the operation to any two elements of the set the result is
also an element of the set. For example, $2 + 2$ is $4$, which is also
an element of the natural numbers $\mathbb{N}$.

[fn:7] At this point you might be getting lost in all the
parentheses. Don't worry, Emacs and other editors for Lisp and Scheme
have parentheses-matching highlighting so you always know which
enclosing set of parentheses you are in.

[fn:8] ...some suggest telepathy...

[fn:9] From now on for visual purposes we will forego the code block
wrappers , i.e., ~#+begin_src scheme ... #+end_src~, and just display
the code and the results. When in doubt about exactly what the code
block wrapper should be, consult the raw version of this page.

[fn:10] Anything following a ";" is a /comment/ for the rest of that
line and is not evaluated, rather, just passed on. However, with
org-mode Babel's literate programming we need far less in-code
comments since we can make all the commentary we need before and after
the block.

[fn:11] This is also referred to as /dotted pair/.

[fn:12] Realize of course that \\
~(1 . (2 . (3 . NIL)))~ \\
is just the dotted symbolic way of expressing \\
~(cons 1 (cons 2 (cons 3 '())))~. \\
The dotted version doesn't work as actual Scheme code.

[fn:13] [[https://en.wikipedia.org/wiki/Binary_operation][This Wikipedia article on binary operations]] is quite
abstract-formal, but we'll be getting into this lore meticulously as
we progress. It, like all of higher math, assumes set theory, which is
also the basis of much computer science theory.

[fn:14] Some Scheme REPLs will give the error ~wrong number of
arguments~ because it was expecting exactly two inputs.

[fn:15] *precedence* is the order in which a simplification
follows. Parentheses are usually the highest precedence, e.g., $4 \cdot
(2 + 3) = 20$ because by parenthesizing the $(2 + 3)$ we created
precedence over the multiplication.

[fn:16] For now we'll stick to the layman's use of the term
/sequence/. Later, we'll dive into what we mean mathematically.

[fn:17] Recursion and [[https://en.wikipedia.org/wiki/Mathematical_induction][induction]] are closely related. We'll look into
induction later.

[fn:18] /...until true/ belies a test for true or false, doesn't it?
Hold that thought...

[fn:19] This math nesting in parentheses is just like nesting in
parentheses in Scheme of course. Parentheses keep computational law
and order. The yellow-highlighting emphasizes the substitution.
