<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-03-08 Sat 00:05 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="./tufte.css" type="text/css">
<link rel="stylesheet" href="./ox-tufte.css" type="text/css">
<style>
article > div.org-src-container {
width: var(--ox-tufte-content-width);
max-width: var(--ox-tufte-content-width);
clear: none;
}
article > section .org-src-container {
width: var(--ox-tufte-src-code-width);
max-width: var(--ox-tufte-src-code-width);
clear: none;
}
div.org-src-container > pre { clear: none; }
pre.example {clear: none; }
</style>
<style> .title { display: none; } </style>
<style> caption.t-bottom { caption-side: bottom; } </style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-euler',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<article id="content" class="content">
<div class="header">
<link rel="stylesheet" href="hamb.css">
<link rel="stylesheet" href="tufte.css">
<link rel="stylesheet" href="ox-tufte.css">
<img src="./images/UNPendulumTop.png"  style="padding: 0px 0px 0px 0px" alt="United Nations pedulum" class="left">


<p>

<nav role="navigation">
  <div id="menuToggle">
    <!--
    A fake / hidden checkbox is used as click reciever,
    so you can use the :checked selector on it.
    -->
    <input type="checkbox" />
    
    <!--
    Some spans to act as a hamburger.
    
    They are acting like a real hamburger,
    not that McDonalds stuff.
    -->
    <span></span>
    <span></span>
    <span></span>
    
    <!--
    Too bad the menu has to be inside of the button
    but hey, it's pure CSS magic.
    -->
    <ul id="menu">
      <a href="index.html" target="_blank"><li>Home</li></a>
      <a href="blog.html" target="_blank"><li>Blog</li></a>
      <a href="preface.html" target="_blank"><li>Preface</li></a>
      <a href="preliminaries.html" target="_blank"><li>Rabbit Holes</li></a>
      <li>Numbers</li>
      <ul>
         <a href="HRGettingStarted1.html" target="_blank"><li>Getting Started 1</li></a>
         <a href="HRGettingStarted2.html" target="_blank"><li>Getting Started 2</li></a>
         <a href="numbers1.html" target="_blank"><li>Numbers 1</li></a>
         <a href="numbers2.html" target="_blank"><li>Numbers 2</li></a>
      </ul>
    </ul>
  </div>
</nav>
</div>
</p>
<section id="outline-container-org9639605" class="outline-2">
<h2 id="org9639605">Numbers</h2>
</section>
<section id="outline-container-org0043671" class="outline-2">
<h2 id="org0043671">Introduction</h2>
<div class="outline-text-2" id="text-org0043671">
<p>
Numbers begin for many of us when our parents had us hold up three
fingers to show everyone we were three years old. And so we were
introduced to the unique world of seeing <i>magnitude</i> as an abstraction
as we &ldquo;map&rdquo; or connect three fingers to three years of our life.
</p>

<p>
Then at some point we learn what mathematician Eugenia Cheng<label id='fnr.1' for='fnr-in.1.4993595' class='margin-toggle sidenote-number'><sup class='numeral'>1</sup></label><input type='checkbox' id='fnr-in.1.4993595' class='margin-toggle'><span class='sidenote'><sup class='numeral'>1</sup>
See her popular layman&rsquo;s book <i>How To Bake \(\pi\;\)</i>. One
interesting aspect of this book is her treatment of <i>category theory</i>,
which is a superset of type theory, much of which is baked into
Haskell.
</span>
calls the &ldquo;counting poem,&rdquo; i.e., we learn how to count from one to
ten, usually on our fingers. Then begins the typical K-12 math
curriculum of &ldquo;When you see this, do this&rdquo; conditioned learning. &lt;insert big
<b>alas</b> here&gt;
</p>

<p>
Sometime in the later college years<label id='fnr.2' for='fnr-in.2.1716693' class='margin-toggle sidenote-number'><sup class='numeral'>2</sup></label><input type='checkbox' id='fnr-in.2.1716693' class='margin-toggle'><span class='sidenote'><sup class='numeral'>2</sup>
In many places in the world the typical American college
Freshman-Sophomore math sequence of calculus, diff-eqs, and linear
algebra is completed at the college-prep level. Germany and
Switzerland, for example, have college freshmen starting with
Analysis.
</span> &#x2014; after Frosh calculus,
differential equations, and linear algebra &#x2014; begins &ldquo;higher math.&rdquo;
These upper semester math courses are almost like a complete reboot of
math, weeding out vague, ad hoc, <i>parochial</i><label id='fnr.3' for='fnr-in.3.5738824' class='margin-toggle sidenote-number'><sup class='numeral'>3</sup></label><input type='checkbox' id='fnr-in.3.5738824' class='margin-toggle'><span class='sidenote'><sup class='numeral'>3</sup>
<b>parochial</b>: &#x2026; very limited or narrow in scope or outlook;
provincial&#x2026;
</span> notions about math,
replacing them with a rigorous, theoretical, formalistic, foundational
understanding of math. As mathematician Joe Fields says, this is when
you stop being a &ldquo;see this, do this&rdquo; calculator and become a prover,
i.e., a deeper thinker about math.
</p>

<p>
<i><a href="https://en.wikipedia.org/wiki/Set_theory">Set theory</a></i> is a big part of this formalism<label id='fnr.4' for='fnr-in.4.9481302' class='margin-toggle sidenote-number'><sup class='numeral'>4</sup></label><input type='checkbox' id='fnr-in.4.9481302' class='margin-toggle'><span class='sidenote'><sup class='numeral'>4</sup>
Make sure you&rsquo;re attacking the <i>LibreTexts</i> series, e.g.,
one of the first three rabbit holes in the math section.
</span>. Set theory is an
exacting, don&rsquo;t-take-stuff-for-granted world, which turns out to be
good for the computer world as well since computer circuits don&rsquo;t
attend human grade school, don&rsquo;t learn poems, and don&rsquo;t have
fingers<label id='fnr.5' for='fnr-in.5.2232248' class='margin-toggle sidenote-number'><sup class='numeral'>5</sup></label><input type='checkbox' id='fnr-in.5.2232248' class='margin-toggle'><span class='sidenote'><sup class='numeral'>5</sup>
If machines were capable of conditioned learning, your car
should be able to self-drive certain oft-travelled routes, e.g., from
your home to the grocery store.
</span>. Again, if you want a computer to understand something,
you have to spell it out in very precise and exacting ways. That is to
say you&rsquo;re always facing logical entailment (LE) with computers. So how
<i>does</i> a computer understand numbers? And isn&rsquo;t a computer doing
numbers the way a clock does time?  After all, a ticking clock that
you wind up has no real concept of time&#x2026;
</p>

<p>
One fascinating twist of mathematical history is how, on the whole,
the Greeks seemed to favor geometry over numbers. Their mastery of
geometry really got going with <a href="https://en.wikipedia.org/wiki/Euclid%27s_Elements">Euclid&rsquo;s Elements</a> ca. 300 BC, which
starts with just a point and a line and from there builds up expansive
theorems about complex geometric shapes, i.e., no numbers<label id='fnr.6' for='fnr-in.6.8061131' class='margin-toggle sidenote-number'><sup class='numeral'>6</sup></label><input type='checkbox' id='fnr-in.6.8061131' class='margin-toggle'><span class='sidenote'><sup class='numeral'>6</sup>
It was a long-revered feat of logical minimalism that all
two-dimensional shapes in <i>Elements</i> could be produced with just a
compass and a straightedge. Follow the Wikipedia link and note the
animation of <a href="https://en.wikipedia.org/wiki/Euclid%27s_Elements#/media/File:HexagonConstructionAni.gif">the construction of a hexagon</a>. It wasn&rsquo;t until the
development of calculus and infinitesimal methods in the Renaissance
that this compass-and-stick purity was set aside.
</span>. Even
when Euclid&rsquo;s geometry worked with the concepts of length and angles,
no numbers were employed<label id='fnr.7' for='fnr-in.7.6442931' class='margin-toggle sidenote-number'><sup class='numeral'>7</sup></label><input type='checkbox' id='fnr-in.7.6442931' class='margin-toggle'><span class='sidenote'><sup class='numeral'>7</sup>
Later we&rsquo;ll explore how Descartes united algebra and geometry.
</span>.
</p>

<p>
With this section we&rsquo;ll talk about numbers in a fairly theoretical but
not really difficult manner. Along with the math, we&rsquo;ll do some dives
into Haskell that you should be ready for<label id='fnr.8' for='fnr-in.8.852288' class='margin-toggle sidenote-number'><sup class='numeral'>8</sup></label><input type='checkbox' id='fnr-in.8.852288' class='margin-toggle'><span class='sidenote'><sup class='numeral'>8</sup>
Make sure you&rsquo;re getting along with the Haskell rabbit hole materials &#x2014; at
the very least worked through half of LYAHFFG.
</span>.
</p>
</div>
</section>
<section id="outline-container-org1520f12" class="outline-2">
<h2 id="org1520f12">Number taxonomy</h2>
<div class="outline-text-2" id="text-org1520f12">
<p>
We&rsquo;ll give a quick, general introduction of how numbers are grouped
according to their traits and properties, i.e., a sort of math
taxonomist&rsquo;s view of numbers. Don&rsquo;t worry about these definitions yet,
just be aware that numbers come in different &ldquo;species&rdquo;
</p>

<ul class="org-ul">
<li>\(\mathbb{N}\;\): the <i>natural</i> counting numbers, often starting
with \(0\;\); otherwise, with \(1\;\).</li>
<li>\(\mathbb{Z}\;\): whole number <i>integers</i> &#x2014; just like \(\mathbb{N}\;\)
but with the positive numbers duplicated as negative numbers, along
with \(0\;\) between them.</li>
<li>\(\mathbb{Q}\;\): the <i>rational</i> numbers &#x2014; composed as
\(\frac{a}{b}\;\) where \(a\) and \(b\) are integers and \(b\) cannot be
\(0\;\) &#x2014; although this is really too simple and we&rsquo;ll be expanding
on it later.</li>
<li>\(\mathbb{R}\;\): the <i>real</i> numbers are the limit of a convergent
sequence of rational numbers&#x2026; Really? Yes, but this is a higher
math sort of definition. Suffice it to say for now reals are the
rational numbers (recurring decimals) along with <b>ir</b>-rational
numbers (non-recurring decimals), e.g., the square root of
\(2\;\). <i>Lots</i> more to come&#x2026;</li>
<li>\(\mathbb{C}\;\): the <i>complex</i> numbers are of the form \(a + bi\;\)
where \(a\) and \(b\) are real numbers and \(i\) is the square root of
\(-1\;\). Again, lots more later.</li>
</ul>

<p>
Yes, this is a mathematical taxonomy for numbers, i.e., numbers are
grouped according to their mathematical traits and behavior, e.g.,
what you can do with them in the wild<label id='fnr.9' for='fnr-in.9.1471703' class='margin-toggle sidenote-number'><sup class='numeral'>9</sup></label><input type='checkbox' id='fnr-in.9.1471703' class='margin-toggle'><span class='sidenote'><sup class='numeral'>9</sup>
One aspect to keep in mind is that each number species is a
subset of the next one up, i.e., \(\mathbb{N} \subset \mathbb{Z} \subset \mathbb{Q}
\subset \mathbb{R}\ \subset \mathbb{C}\;\;\;\). Historically, we could say one
evolved from the previous as math got more sophisticated and exacting
with its definitions. We&rsquo;ll go into the details of how
this works.
</span>. For example, note the
definition of \(\mathbb{Q}\;\), the rational numbers, or the
\(\mathbb{R}\;\), the real numbers. But let&rsquo;s not use loose metaphors
like species anymore, rather, consider these groupings to be <i>sets</i>,
e.g., the <i>set</i> of all counting numbers, the <i>set</i> of all complex
numbers. We will proceed with numbers from a set theory perspective,
using set theoretic explanations and especially notation along the
way<label id='fnr.10' for='fnr-in.10.9670868' class='margin-toggle sidenote-number'><sup class='numeral'>10</sup></label><input type='checkbox' id='fnr-in.10.9670868' class='margin-toggle'><span class='sidenote'><sup class='numeral'>10</sup>
Set theory is the basic foundation of math, and is fundamental
to the discrete math of computer science. But there&rsquo;s a new kid is on
the block, namely, <i>category theory</i>, which is even more foundational
than set theory. With Haskell we&rsquo;ll stick a toe into category theory
now and then, just enough to get a few shivers.
</span>.
</p>
</div>
<div id="outline-container-org79c4fb7" class="outline-3">
<h3 id="org79c4fb7">Numbers in Haskell</h3>
<div class="outline-text-3" id="text-org79c4fb7">
<p>
Always mindful of LE, we must negotiate a
computer-logical world in which numbers are ultimately handled at the
level of encoded logic on electrical circuits. But at this point we
may point out that Haskell for its part mirrors the number system&rsquo;s
categorizations with number types<label id='fnr.11' for='fnr-in.11.2061938' class='margin-toggle sidenote-number'><sup class='numeral'>11</sup></label><input type='checkbox' id='fnr-in.11.2061938' class='margin-toggle'><span class='sidenote'><sup class='numeral'>11</sup>
For now don&rsquo;t worry about <i>precision</i> and
<i>floating-point</i>. These ultimately refer to how computers with
electrical logic circuits represent numbers. We&rsquo;ll dive into all that
later.
</span>.
</p>

<ul class="org-ul">
<li><code>Int</code>: limited-precision integers in at least the range \([-2^{29} ,
  2^{29})\;\).</li>
<li><code>Integer</code>: arbitrary-precision integers (read <i>lots</i> of integers,
lots more than <code>Int</code>).</li>
<li><code>Rational</code>: arbitrary-precision rational numbers.</li>
<li><code>Float</code>: single-precison floating-point numbers.</li>
<li><code>Double</code>: double-precision floating-point numbers</li>
<li><code>Complex</code>: complex numbers as defined in <code>Data.Complex</code>.</li>
</ul>

<p>
One missing category is \(\mathbb{N}\;\). We&rsquo;ll take a special look into
what Haskell thinks about natural numbers up ahead.
</p>
</div>
</div>
</section>
<section id="outline-container-org0c2fec5" class="outline-2">
<h2 id="org0c2fec5">The qualities of quantity</h2>
<div class="outline-text-2" id="text-org0c2fec5">
<p>
A number is a concept, first and foremost a symbol related to
<i>quantity</i> or <i>magnitude</i>. And as such a number has great powers of
abstraction. Numbers may be applied in the abstraction exercises of
counting or enumerating, as well as measuring things<label id='fnr.12' for='fnr-in.12.7200933' class='margin-toggle sidenote-number'><sup class='numeral'>12</sup></label><input type='checkbox' id='fnr-in.12.7200933' class='margin-toggle'><span class='sidenote'><sup class='numeral'>12</sup>
But then measuring must be &ldquo;quantified&rdquo; by counting unit-wise
what was measured; hence, everything comes back to counting. This will
come up when we explore real numbers versus rational numbers.
</span>. 
</p>

<img src="./images/threediagram1.png" style="padding: 10px 0px 0px 0px" width="280" alt="Diagram of three" class="center">
<span class="cap">The concept, the embodiment of three and "three-ness"</span>

<p>
Consider these <i>qualities</i> of quantities
</p>

<ul class="org-ul">
<li>cardinality, or <i>how many?</i></li>
<li>ordinality, or <i>what order?</i></li>
<li>enumeration, or, generally, <i>how do we count things?</i></li>
</ul>

<p>
As we&rsquo;ve said, when we bring the computer into this quantification
game, we cannot assume these basic qualities as given<label id='fnr.13' for='fnr-in.13.711221' class='margin-toggle sidenote-number'><sup class='numeral'>13</sup></label><input type='checkbox' id='fnr-in.13.711221' class='margin-toggle'><span class='sidenote'><sup class='numeral'>13</sup>
Inside your head you automatically know how many and in what
order the numbers \(1\) through \(10\) are. However, a computer must be
taught such basic quantitative qualities.
</span>.
</p>
</div>
<div id="outline-container-orgaf542ca" class="outline-3">
<h3 id="orgaf542ca">Cardinality</h3>
<div class="outline-text-3" id="text-orgaf542ca">
<p>
In everyday language <a href="https://en.wikipedia.org/wiki/Cardinal_numeral">cardinal numbers</a> are simply the counting numbers,
\(\mathbb{N}\;\), either as words or numerical symbols. In set theory,
however, <i>cardinality</i> has a different meaning, i.e., <i>the number the
objects in a set</i>. So if we consider the box of stars in the diagram
above to be a <i>set</i> of stars, then the cardinality of this set is \(3\)
since there are three stars<label id='fnr.14' for='fnr-in.14.7408686' class='margin-toggle sidenote-number'><sup class='numeral'>14</sup></label><input type='checkbox' id='fnr-in.14.7408686' class='margin-toggle'><span class='sidenote'><sup class='numeral'>14</sup>
We indicate the set&rsquo;s cardinality by surrounding the symbol for
a set with <i>pipes</i> ( <b><b>|</b></b> ), e.g., \(|S_{stars}|\;\). This is not the same
as <i>absolute value</i>, although they might be cousins.
</span>
</p>

\begin{align*}
|\,S_{stars} \,| &= 3 \\
|\,\{a, b, c\}\,| &= 3 \\
|\,\mathbb{N}\,| &= \infty \\
|\,\mathbb{Z}\,| &= \infty
\end{align*}

<p>
But why are we being so &ldquo;conceptual&rdquo; about the simple idea of amount,
and why must we give it a fancy name? Again, math likes to <i>formalize</i>
things, nail things down. Starting with exactness and precision we can
then build very complex and logically-based math<label id='fnr.15' for='fnr-in.15.9115149' class='margin-toggle sidenote-number'><sup class='numeral'>15</sup></label><input type='checkbox' id='fnr-in.15.9115149' class='margin-toggle'><span class='sidenote'><sup class='numeral'>15</sup>
Have a look at <a href="https://en.wikipedia.org/wiki/Cardinality">this Wikipedia discussion of cardinality</a>. Later
we will look into <i><a href="https://en.wikipedia.org/wiki/Cardinal_number">cardinal numbers</a></i>, which is a deeper dive into set
theory.
</span>. Now, if two
sets have the same cardinality, is this somehow significant? Above, we
see that both the set of natural numbers and the set of integers have
infinity as their cardinality. Are, therefore, \(\mathbb{N}\) and
\(\mathbb{Z}\) the same &ldquo;size?&rdquo;
</p>

<p>
<font color = "#650d1c">The <i>bijection principle</i> states that
two sets have the same size <i>if and only if</i> there is a <i>bijection</i>
(injective <i>and</i> surjective together) between
them</font><label id='fnr.16' for='fnr-in.16.362816' class='margin-toggle sidenote-number'><sup class='numeral'>16</sup></label><input type='checkbox' id='fnr-in.16.362816' class='margin-toggle'><span class='sidenote'><sup class='numeral'>16</sup>
We&rsquo;ll look at injective, surjective, and bijective when we
delve into functions from a set theory perspective. Also, mathematical
logic will introduce us to <i>if and only if</i>.
</span>.
</p>

<p>
Which means \(|\,S_{stars} \,|\;\) and \(|\,\{a, b, c\}\,|\;\) can be matched
up one-to-one, thus, they must have the same cardinality. But again,
what about sets of things that supposedly have an infinite size? How
do we &ldquo;count,&rdquo; or &ldquo;pair up&rdquo; infinite sets<label id='fnr.17' for='fnr-in.17.9956131' class='margin-toggle sidenote-number'><sup class='numeral'>17</sup></label><input type='checkbox' id='fnr-in.17.9956131' class='margin-toggle'><span class='sidenote'><sup class='numeral'>17</sup>
To excite your curiosity, is \(\infty + 1\) still just \(\infty\;\)? Are
these sorts of imaginings about infinity ever found in the real world?
These and many other twisty-turns are up ahead.
</span>?  Surprisingly, there
are different kinds of infinity &#x2014; which necessitates this exactness
and preciseness. More about cardinality theory later.
</p>
</div>
<div id="outline-container-orgb22ef7e" class="outline-4">
<h4 id="orgb22ef7e">Haskell and cardinality</h4>
<div class="outline-text-4" id="text-orgb22ef7e">
<p>
The first thing to know about Haskell and set theory is, yes, we can
do real set theory with Haskell&rsquo;s <code>Data.Set</code> package. But as beginners
learning the ropes we will start with a simpler representation of sets
through Haskell&rsquo;s basic <i>list</i> data structure. Realize, however, that
a list is not a set; they are two different beasts, and we&rsquo;ll have to
account for that. For one, a set may have duplicates, whereas a list
holds a definite <i>sequence</i> of things, i.e., every element of the list
is unique, even if some elements are repeated<label id='fnr.18' for='fnr-in.18.1650310' class='margin-toggle sidenote-number'><sup class='numeral'>18</sup></label><input type='checkbox' id='fnr-in.18.1650310' class='margin-toggle'><span class='sidenote'><sup class='numeral'>18</sup>
So it&rsquo;s not really a &ldquo;grocery list,&rdquo; it&rsquo;s a &ldquo;grocery set&rdquo;
since \(\{eggs,sugar,coffee,eggs\}\;\;\;\) is invariably interpreted as
just \(\{eggs,sugar,coffee\}\;\;\), right? Or would you go ahead and
get eggs twice?
</span>. So the <i>set</i>
\(\{1,2,1\}\;\) is the same as \(\{1,2\}\;\) is the same as \(\{2,1,1\}\;\)
because sets don&rsquo;t mind duplicates, nor do they worry about
order<label id='fnr.19' for='fnr-in.19.1165058' class='margin-toggle sidenote-number'><sup class='numeral'>19</sup></label><input type='checkbox' id='fnr-in.19.1165058' class='margin-toggle'><span class='sidenote'><sup class='numeral'>19</sup>
Why is this? There is a LE to the definition
of a set union, namely, \(A \cup B = \{x \;\;|\;\; x \in A \;\;\;or\;\;\; x \in
B \}\quad\). Consider the sets \(A = \{1,2,3\}\;\), \(B = \{2,3,4\}\;\),
and \(C = \{3,4,5\}\;\). If you draw out Their union \(A \cup B \cup C = \{x
\;|\; x \in A \;\;\text{or}\;\;x \in B\;\; \text{or}\;\;x \in C \}\quad\;\;\) as
a Venn diagram, you&rsquo;ll see how duplicates get left out.
</span>. But the <i>lists</i> <code>[1,2,1]</code>, <code>[1,2]</code>, and <code>[2,1,1]</code> are in
fact all different lists. Initially, we&rsquo;ll practice set theory with
lists and build alternate set theory code based on lists. Then when we
understand &ldquo;squirrel math&rdquo; a little more, i.e., how to work with the
data structures known as <i>trees</i>, we&rsquo;ll do proper set theory with
Haskell&rsquo;s set theory module, <a href="https://hackage.haskell.org/package/containers-0.6.6/docs/Data-Set.html">Data.Set</a><label id='fnr.20' for='fnr-in.20.7036216' class='margin-toggle sidenote-number'><sup class='numeral'>20</sup></label><input type='checkbox' id='fnr-in.20.7036216' class='margin-toggle'><span class='sidenote'><sup class='numeral'>20</sup>
Take a look at this Hackage page. It has <a href="https://haskell-containers.readthedocs.io/en/latest/set.html">a nice
little intro to Haskell&rsquo;s sets</a>. Get in the habit of perusing Hackage
whenever you&rsquo;re using a Haskell function or data type you don&rsquo;t quite
understand. Sometimes you&rsquo;ll have to just dive into the code, but
sometimes there are excellent intro docs like this.
</span>.  For the immediate
future we&rsquo;ll consider a list to be a beginner&rsquo;s substitute for a
set. And so a simple &ldquo;how many&rdquo; function on a list standing in for a
set is <i>length</i>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd9cd98a"><span class="org-haskell-definition">length</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,2,3,4,5<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
5
</pre>


<p>
Again, more excitement to come. Watch this space.
</p>
</div>
</div>
</div>
<div id="outline-container-org50a2617" class="outline-3">
<h3 id="org50a2617">Ordinality</h3>
<div class="outline-text-3" id="text-org50a2617">
<p>
In everyday language the concept of order is conveyed when we say
<i>first, second, third, fourth,</i> etc<label id='fnr.21' for='fnr-in.21.4017446' class='margin-toggle sidenote-number'><sup class='numeral'>21</sup></label><input type='checkbox' id='fnr-in.21.4017446' class='margin-toggle'><span class='sidenote'><sup class='numeral'>21</sup>
See <a href="https://en.wikipedia.org/wiki/Ordinal_numeral">this</a> brief discussion.
</span>. And we&rsquo;re done, right? But
again, as seen from set theory &#x2014; as well as from the computer world
&#x2014; (re-)establishing order is important and cannot always be taken
for granted. In fact, a great deal of math lore surrounds ordinality.
</p>

<p>
The counting numbers, the set \(\mathbb{N}\;\), would seem to have order
built in. For example, everybody knows that \(3\) comes after \(2\;\)
etc., they&rsquo;re in ascending order based on the incrementally greater
amounts they represent. And neither does the set \(\mathbb{N}\;\) have
repeats. But order, and all it&rsquo;s implications, is not always a given
in real life. What if we wrote the numbers from one to ten on small
squares of paper, put them in a box, and then shook them out on the
floor in a straight line?  Would they be in order? Chances are,
no. And what about sets of things that aren&rsquo;t inherently numerical,
such as colors?
</p>

<p>
So if we don&rsquo;t have things in proper order&#x2014;which is often the case
in the real world&#x2014;we have to put things in order ourselves. And that
means we will need to <i>sort</i> a set of unsorted elements into some
order. Sorting, in fact, is one of the more basic tasks computers do
in the everyday world.
</p>

<p>
But to sort we need to compare things. Obviously, ten whole numbers
written clearly on ten squares of paper can be easily sorted by
hand<label id='fnr.22' for='fnr-in.22.4849930' class='margin-toggle sidenote-number'><sup class='numeral'>22</sup></label><input type='checkbox' id='fnr-in.22.4849930' class='margin-toggle'><span class='sidenote'><sup class='numeral'>22</sup>
A jigsaw puzzle can be seen as a sorting game based on shape,
color, and patterns of the pieces.
</span>. But what if we had thousands of squares of paper, each
with a unique number? Then we&rsquo;d have a long task ahead of us. But no
matter how big or small the task, we would compare <i>two</i> numbers at a
time and then make a judgement based on whether one number was
</p>

<ul class="org-ul">
<li>greater than</li>
<li>equal to</li>
<li>less than</li>
</ul>

<p>
the other number, then rearranging as needed.
</p>
</div>
<div id="outline-container-org05f9cc3" class="outline-4">
<h4 id="org05f9cc3">Ordinality in Haskell</h4>
<div class="outline-text-4" id="text-org05f9cc3">
<p>
Haskell is a typed language with a feature called <i>type
classes</i><label id='fnr.23' for='fnr-in.23.6439167' class='margin-toggle sidenote-number'><sup class='numeral'>23</sup></label><input type='checkbox' id='fnr-in.23.6439167' class='margin-toggle'><span class='sidenote'><sup class='numeral'>23</sup>
For a quick introduction with examples go <a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101">here</a> in LYAHFGG.
</span>. A Haskell type class encompasses traits, patterns,
concepts, or what we might call a certain &ldquo;-ness&rdquo; that can be imparted
to data types. In Haskell, for example, numbers and the characters of
the alphabet can be directly compared for &ldquo;equal-ness,&rdquo; and when we
test at the ghci REPL prompt, this seems to be built-in
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org530237a"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span>5 <span class="org-haskell-operator">==</span> 3<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'a'</span> <span class="org-haskell-operator">==</span> <span class="org-string">'a'</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'b'</span> <span class="org-haskell-operator">==</span> <span class="org-string">'B'</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
Mindful of LE, we see that Haskell&rsquo;s <code>Eq</code> class
housing this equal-ness must have some sort of behind-the-scenes
mechanism that allows us to take two things, analyze them, then return
a decision, true or false (yes they are equal, no they&rsquo;re not equal),
on whether two said things were equal or not &#x2014; all of this just for
doing some typing, e.g., <code>5 == 3</code> into the REPL.
</p>

<p>
Something else to consider is how some things don&rsquo;t necessarily have
the concept of equal or not equal straight out of the box. What if we
created a data type for colors and we wanted to compare the individual
color values for equal-ness? Intuitively, we might say red, yellow,
and blue are equal since they are all primary colors; likewise,
orange, green, and violet are equal because they&rsquo;re the secondary
colors. But what if we just say each color is equal to itself and not
equal to any of the others? &#x2026; So how would we establish equal-ness
for colors? If we want to type <code>Green == Blue</code> into the REPL it&rsquo;s up
to us to have created some sort of equal-ness and told Haskell about
it.
</p>

<p>
Data types that need to establish equal-ness for themselves can apply
to the Haskell <code>Eq</code> type class for membership. Type class membership
is registered with an <i>instance</i> statement. To see all the data types
that have an instance registered with <code>Eq</code> we can use <code>:info</code>
(abbreviated <code>:i</code>) at the REPL<label id='fnr.24' for='fnr-in.24.3919073' class='margin-toggle sidenote-number'><sup class='numeral'>24</sup></label><input type='checkbox' id='fnr-in.24.3919073' class='margin-toggle'><span class='sidenote'><sup class='numeral'>24</sup>
Go ahead and check out the <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Eq.html">hackage.haskell.org</a> entry for <code>Eq</code>
<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Eq.html">here</a>. Note the properties <code>(==)</code> should follow: reflexivity, symmetry,
transitivity, extentionality, and negation. We&rsquo;ll dive into what this
all means when we look closer into the higher algebra of sets and
functions. Note all the built-in, &ldquo;batteries-included&rdquo; <code>Eq</code> instances
for the various types. Some are rather exotic.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</pre>
</div>

<pre class="example" id="org8948797">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
...
instance Eq Int -- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
instance Eq Float -- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
instance Eq Double -- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
instance Eq Char -- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
instance Eq Bool -- Defined in ‘ghc-prim-0.7.0:GHC.Classes’
...
</pre>

<p>
which gives us a long list (abbreviated above) of data types that have
equal-ness defined<label id='fnr.25' for='fnr-in.25.2219476' class='margin-toggle sidenote-number'><sup class='numeral'>25</sup></label><input type='checkbox' id='fnr-in.25.2219476' class='margin-toggle'><span class='sidenote'><sup class='numeral'>25</sup>
Quick LE question: Can functions be compared for equal-ness?
Here&rsquo;s a direct quote from a prominent combinatorics text: <i>When two
formulas enumerate the same set, then they must be equal.</i> But not so
fast in the computer world. To say <code>f x == g x</code> Haskell isn&rsquo;t
logically set up to actually prove (demonstrate) and accept that <code>f</code>
and <code>g</code> always give the same results given the same <code>x</code> input. We
would literally have to test every possible <code>x</code>, which is not
possible. Still, we&rsquo;ll examine this idea a bit closer soon. It&rsquo;s a
real big deal in numerical math.
</span>. Notice the two &ldquo;prescribed&rdquo; methods (functions)
<code>(==)</code> and <code>(/=)</code>. These functions are the mechanism used by <code>Eq</code> to
establish equal-ness. They must be custom defined in each instance
declaration in order for a data type to have its own established
equal-ness<label id='fnr.26' for='fnr-in.26.3691904' class='margin-toggle sidenote-number'><sup class='numeral'>26</sup></label><input type='checkbox' id='fnr-in.26.3691904' class='margin-toggle'><span class='sidenote'><sup class='numeral'>26</sup>
Note <code>{-# MINIMAL (==) | (/=) #-}</code> which is a directive
meaning we may choose to define <b>either</b> <code>(==)</code> <b>or</b> (note the <b>or</b>
pipe <b>|</b> ) <code>(/=)</code>, i.e., we don&rsquo;t actually have to define both because
by defining one, the other will be automatically generated. Neat.
</span>. And so if you create a new type, you, the
programmer, must come up with your own version of these two functions,
<code>(==)</code> and <code>(/=)</code> to establish the trait, the property of equal-ness
for that new data type. As <i>LYAHFGG</i> notes, the type signature for the
equal-ness function <code>(==)</code> is<label id='fnr.27' for='fnr-in.27.4693493' class='margin-toggle sidenote-number'><sup class='numeral'>27</sup></label><input type='checkbox' id='fnr-in.27.4693493' class='margin-toggle'><span class='sidenote'><sup class='numeral'>27</sup>
<code>:t</code> is short for <code>:type</code>.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>t <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
</pre>


<p>
which indicates <code>(==)</code> takes two inputs of some type <code>a</code> and returns a
<code>Bool</code> type, i.e., either <code>True</code> or <code>False</code>. Good, we saw how that
works with our examples above. But there&rsquo;s another wrinkle to this
story. So if <code>(==)</code> is a function that takes two objects of type <code>a</code>,
e.g., two integers, real numbers, characters, booleans, etc., how can
we use this same symbol <code>(==)</code> in so many different contexts?  Looking
above, how did Haskell know to use <i>integer</i> equal-ness rules (defined
by <code>instance Eq Int</code>) when comparing integers, and then <i>letter</i>
equal-ness rules (defined by <code>instance Eq Char</code>) when comparing
letters? This feat is what we call <i>ad hoc polymorphism</i><label id='fnr.28' for='fnr-in.28.6487660' class='margin-toggle sidenote-number'><sup class='numeral'>28</sup></label><input type='checkbox' id='fnr-in.28.6487660' class='margin-toggle'><span class='sidenote'><sup class='numeral'>28</sup>
<i>ad hoc</i>, from Latin <i>to this</i>, is something put together on
the fly for one narrow, pressing, or special purpose. <i>polymorphic</i>,
from Greek <i>polus</i> much, many, and <i>morphism</i>, having the shape, form,
or structure, i.e., having many shapes.
</span>, which
allows just a single function symbol, e.g., <code>(==)</code>, to be used
(<a href="https://en.wikipedia.org/wiki/Operator_overloading">overloaded</a>) in many different contexts. And so Haskell figures out
behind the scenes which instance to apply. Neat.
</p>

<p>
Let&rsquo;s take a closer look at a color type by defining our own<label id='fnr.29' for='fnr-in.29.4666375' class='margin-toggle sidenote-number'><sup class='numeral'>29</sup></label><input type='checkbox' id='fnr-in.29.4666375' class='margin-toggle'><span class='sidenote'><sup class='numeral'>29</sup>
As LYAHFGG says, <code>Read</code> and <code>Show</code> are also type classes to
which you may register your data type. Here we&rsquo;ve used the <code>deriving</code>
keyword to let Haskell figure it out, i.e., we&rsquo;re not defining
<code>Read</code> and <code>Show</code> ourselves; rather, we&rsquo;re telling Haskell to
auto-generate and register these instances for us.
</span> <sup>, </sup><label id='fnr.30' for='fnr-in.30.600043' class='margin-toggle sidenote-number'><sup class='numeral'>30</sup></label><input type='checkbox' id='fnr-in.30.600043' class='margin-toggle'><span class='sidenote'><sup class='numeral'>30</sup>
We&rsquo;ll go into more detail about declaring our own data types
as we progress. But for now we&rsquo;ll say <code>Color</code> is a <i>sum</i> type, as
opposed to a <i>product</i> type. Sum types are patterned after the
<i>addition principle</i> which we&rsquo;ll also go into later. Note, the pipes
\(\;|\;\) between the colors can be understood as logical <i>or</i>&#x2014;as in
we must choose one <i>or</i> the other of the colors.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org9c54a6f"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Color</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Green</span> <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span>,<span class="org-haskell-constructor">Read</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Obviously, the colors red, yellow, blue, and green have no intrinsic
numerical properties by which to compare one with the other. However,
Haskell&rsquo;s type class system still allows us to create some manner of
equal-ness for it. And so we write this version of an <i>instance</i> of
<code>Eq</code> for <code>Color</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgf4316c4"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Eq</span> <span class="org-haskell-type">Color</span> <span class="org-haskell-keyword">where</span>
  <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>      <span class="org-comment-delimiter">-- </span><span class="org-comment">could also be (==) Red Red = True</span>
  <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-constructor">Green</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Green</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">True</span>
  <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">False</span>         <span class="org-comment-delimiter">-- </span><span class="org-comment">anything getting to this point must be false</span>
</pre>
</div>

<p>
And so we&rsquo;ve hand-coded our own equal-ness for <code>Color</code> by spelling out
how <code>(==)</code> works for <code>Color</code>. This literally tells Haskell what
<code>Color</code> equal-ness should be by customizing how the function <code>(==)</code>
should work. Let&rsquo;s have another look at the type signature for <code>(==)</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>t <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
(==) :: Eq a =&gt; a -&gt; a -&gt; Bool
</pre>


<p>
As LYAHFGG notes, the <code>Eq a</code> part is known as a <i>class
constraint</i>. This means whatever <code>a</code> might be<label id='fnr.31' for='fnr-in.31.7457167' class='margin-toggle sidenote-number'><sup class='numeral'>31</sup></label><input type='checkbox' id='fnr-in.31.7457167' class='margin-toggle'><span class='sidenote'><sup class='numeral'>31</sup>
&#x2026;and this is an example of <i>parametric polymorphism</i> where
the <i>parameter</i> (aka <i>type variable</i>) <code>a</code> can be any data type. In
Haskell, smaller-case letters such as <code>a</code>, <code>b</code>, <code>c</code>, etc., are generic
parameter names and can indicate any data type. In <code>(==) :: Eq a =&gt; a
-&gt; a -&gt; Bool</code> we see that two inputs of the same type <code>a</code> are fed to
<code>(==)</code>, which produces a <code>Bool</code> output. Another example would be
<code>myFunc :: a -&gt; b -&gt; a</code>. Here the type signature says the inputs don&rsquo;t
have to be of the same type (although they could be), but no matter
what type the parameter <code>b</code> is, the output will be of type <code>a</code>.
</span>, it must have an
equal-ness instance already registered for it &#x2014; which we do &#x2014;
otherwise, Haskell won&rsquo;t know how to compare two things of <code>a</code> for
equal-ness<label id='fnr.32' for='fnr-in.32.8147625' class='margin-toggle sidenote-number'><sup class='numeral'>32</sup></label><input type='checkbox' id='fnr-in.32.8147625' class='margin-toggle'><span class='sidenote'><sup class='numeral'>32</sup>
For our <code>Color</code> we&rsquo;ve created our own equal-ness, although in
this example we could have let Haskell figure it out, i.e., <code>...|
Green deriving (Eq)</code> would have done the same thing. This was an easy
one. Haskell can&rsquo;t always figure out the less obvious cases.
</span>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Red</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">/=</span> <span class="org-haskell-constructor">Green</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
Good, it&rsquo;s working and we now can compare <code>Color</code> values for
equal-ness, but how do we <i>order</i> colors? No matter how we establish
one color before the other, it might seem arbitrary, but we can do it
if we want. For basic order-ness Haskell has the type class <code>Ord</code> to
which types can register
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgdf201f6"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Ord</span>
</pre>
</div>

<pre class="example" id="org0037182">
type Ord :: * -&gt; Constraint
class Eq a =&gt; Ord a where
  compare :: a -&gt; a -&gt; Ordering
  (&lt;) :: a -&gt; a -&gt; Bool
  (&lt;=) :: a -&gt; a -&gt; Bool
  (&gt;) :: a -&gt; a -&gt; Bool
  (&gt;=) :: a -&gt; a -&gt; Bool
  max :: a -&gt; a -&gt; a
  min :: a -&gt; a -&gt; a
  {-# MINIMAL compare | (&lt;=) #-}
  	-- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance [safe] Ord Color -- Defined at src/omni1_1.hs:50:10
instance [safe] Ord Color2 -- Defined at src/omni1_1.hs:62:70
instance Ord Integer -- Defined in ‘GHC.Num.Integer’
instance Ord () -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b) =&gt; Ord (a, b)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c) =&gt; Ord (a, b, c)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d) =&gt; Ord (a, b, c, d)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e) =&gt; Ord (a, b, c, d, e)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =&gt;
         Ord (a, b, c, d, e, f)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =&gt;
         Ord (a, b, c, d, e, f, g)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =&gt;
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =&gt;
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =&gt;
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Bool -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Char -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Double -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Float -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Int -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Ordering -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord a =&gt; Ord (Solo a)
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Word -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord a =&gt; Ord [a]
  -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Integral a =&gt; Ord (Ratio a) -- Defined in ‘GHC.Real’
instance (Ord a, Ord b) =&gt; Ord (Either a b)
  -- Defined in ‘Data.Either’
instance Ord a =&gt; Ord (Maybe a) -- Defined in ‘GHC.Maybe’
</pre>

<p>
Note how the <code>Ord</code> declaration itself has a class constraint, i.e.,
<code>Eq a =&gt;</code>. This means any data type <code>a</code> must already have its <code>Eq</code>
instance registered. Hence, <code>Eq</code> is a sort of super-class, and yes,
type classes can build hierarchies of themselves.
</p>

<p>
Again, we see <code>Ord</code> has a minimum requirement for order-ness, namely,
that we define the method<label id='fnr.33' for='fnr-in.33.4007355' class='margin-toggle sidenote-number'><sup class='numeral'>33</sup></label><input type='checkbox' id='fnr-in.33.4007355' class='margin-toggle'><span class='sidenote'><sup class='numeral'>33</sup>
The habit of calling a set of functions associated with a
Haskell type class <i>methods</i> might be a hold/spill-over from the world
of object-oriented programming where an OOP class will have method
functions attached to it. This is called <i>encapsulation</i>, i.e., a
system for keeping things that belong together together. However, an
OOP class and a Haskell type class are entirely different beasts. So
let&rsquo;s keep our head stuck in the Haskell particle accelerator for
now&#x2026;
</span> (function) <code>compare</code> &#x2026; and then we
get all the other order-ness methods, <code>(&lt;)</code> &#x2026; <code>min</code> for free, as in
Haskell is smart enough to figure them out just based on what you gave
for <code>compare</code>. Neat<label id='fnr.34' for='fnr-in.34.5888636' class='margin-toggle sidenote-number'><sup class='numeral'>34</sup></label><input type='checkbox' id='fnr-in.34.5888636' class='margin-toggle'><span class='sidenote'><sup class='numeral'>34</sup>
In general, anytime your programming language starts writing
code for you, it&rsquo;s cool&#x2026;
</span>.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org5dc7041"><span class="org-haskell-constructor">:</span>t compare
</pre>
</div>

<pre class="example">
compare :: Ord a =&gt; a -&gt; a -&gt; Ordering
</pre>


<p>
The function <code>compare</code> is, like <code>(==)</code>, a binary (two inputs)
operation that takes inputs of the same data type <code>a</code> and returns
something of type <code>Ordering</code>. So what is <code>Ordering</code>? Let&rsquo;s ask
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org9f6b9d4"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Ordering</span>
</pre>
</div>

<pre class="example" id="org4d96662">
type Ordering :: *
data Ordering = LT | EQ | GT
  	-- Defined in ‘ghc-prim-0.9.1:GHC.Types’
instance Monoid Ordering -- Defined in ‘GHC.Base’
instance Semigroup Ordering -- Defined in ‘GHC.Base’
instance Bounded Ordering -- Defined in ‘GHC.Enum’
instance Enum Ordering -- Defined in ‘GHC.Enum’
instance Eq Ordering -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Ord Ordering -- Defined in ‘ghc-prim-0.9.1:GHC.Classes’
instance Read Ordering -- Defined in ‘GHC.Read’
instance Show Ordering -- Defined in ‘GHC.Show’
</pre>

<p>
There&rsquo;s a lot of information here. Note the data type declaration for
<code>Ordering</code> is
</p>

<pre class="example" id="org4a63c07">
...
data Ordering = LT | EQ | GT
...
</pre>

<p>
While the type <code>Bool</code> had two <i>data constructors</i> <code>True</code> and <code>False</code>,
<code>Ordering</code> has three &#x2014; <code>LT</code>, <code>EQ</code>, and <code>GT</code>. Now, let&rsquo;s write code
to register an instance of <code>Ord</code> for <code>Color</code><label id='fnr.35' for='fnr-in.35.5900263' class='margin-toggle sidenote-number'><sup class='numeral'>35</sup></label><input type='checkbox' id='fnr-in.35.5900263' class='margin-toggle'><span class='sidenote'><sup class='numeral'>35</sup>
We make heavy use of the <i>wildcard</i> <code>_</code> by which we mean <i>any</i>
variable can be in the <code>_</code> position. For example <code>compare Red _ = GT</code>
means when we compare <code>Red</code> to anything else, <code>Red</code> will always be
greater than it. We also leveraged the order of these declarations,
i.e., by having <code>compare Red _ = GT</code> at the very start, <code>Red</code> versus
anything will be sorted out first. This is a <i>conditional</i> situation
implicitly, which we&rsquo;ll use lots more.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org1def633"><span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Ord</span> <span class="org-haskell-type">Color</span> <span class="org-haskell-keyword">where</span>
  compare <span class="org-haskell-constructor">Red</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">EQ</span>
  compare <span class="org-haskell-constructor">Red</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GT</span>
  compare <span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">LT</span>
  compare <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">EQ</span>
  compare <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GT</span>
  compare <span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">LT</span>
  compare <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">EQ</span>
  compare <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-keyword">_</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">GT</span>
  compare <span class="org-haskell-keyword">_</span> <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">LT</span>
  compare <span class="org-haskell-constructor">Green</span> <span class="org-haskell-constructor">Green</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">EQ</span>
</pre>
</div>

<p>
Again, the <code>Ord</code> type class required us to create our own <code>compare</code>
method, which painstakingly we did. Now we can compare two values
of <code>Color</code> for order-ness with our basic <code>Ord</code> comparison operators<label id='fnr.36' for='fnr-in.36.1722809' class='margin-toggle sidenote-number'><sup class='numeral'>36</sup></label><input type='checkbox' id='fnr-in.36.1722809' class='margin-toggle'><span class='sidenote'><sup class='numeral'>36</sup>
Remember, math operators in Haskell are just a sort of
function. Which means <code>(==) Red Red</code> is identical to <code>Red ==
Red</code>. Haskell requires operators in the function (<i>prefix</i>) position
to be in parentheses, whereas in the <i>infix</i> (between) position they
can be naked operators. Notice <code>min Red Yellow</code> that <code>min</code> is in the
prefix position. Just put back-ticks around it to use it infix: <code>Red `min` Yellow</code>.
</span>,
<code>&gt;</code>, <code>&lt;</code>, and <code>==</code>,
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgef04619"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Blue</span> <span class="org-haskell-operator">&lt;</span> <span class="org-haskell-constructor">Green</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Red</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Red</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Yellow</span> <span class="org-haskell-operator">&gt;=</span> <span class="org-haskell-constructor">Blue</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="orgac43560"><span class="org-rainbow-delimiters-depth-1">(</span>min <span class="org-haskell-constructor">Red</span> <span class="org-haskell-constructor">Yellow</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&gt;</span> <span class="org-rainbow-delimiters-depth-1">(</span>max <span class="org-haskell-constructor">Blue</span> <span class="org-haskell-constructor">Green</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
Now, how many possible combinations of these four colors would we have
to make in order to test <i>all possible cases</i>? This is a topic the
basics of which we&rsquo;ll explore later. But here&rsquo;s a taste of these
future endeavors. Perhaps you noticed in LYAHFGG the talk about <i><a href="http://learnyouahaskell.com/starting-out#im-a-list-comprehension">list
comprehensions</a></i>. These mimic <i>set comprehensions</i> fairly closely
</p>

\begin{align*}
& C = \{Red,Yellow,Blue,Green \} \\
& \{(x,y) \;|\; x \in C, \;y \in C \}
\end{align*}

<p>
And in Haskell
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgf77f551"><span class="org-haskell-definition">cset</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-constructor">Red</span>,<span class="org-haskell-constructor">Yellow</span>,<span class="org-haskell-constructor">Blue</span>,<span class="org-haskell-constructor">Green</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:333:1-4: warning: [-Wname-shadowing]
    This binding for ‘cset’ shadows the existing binding
      defined at &lt;interactive&gt;:182:1
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org8258019"><span class="org-rainbow-delimiters-depth-1">[</span> <span class="org-rainbow-delimiters-depth-2">(</span>x,y<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> cset, y <span class="org-haskell-operator">&lt;-</span> cset<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[(Red,Red),(Red,Yellow),(Red,Blue),(Red,Green),(Yellow,Red),(Yellow,Yellow),(Yellow,Blue),(Yellow,Green),(Blue,Red),(Blue,Yellow),(Blue,Blue),(Blue,Green),(Green,Red),(Green,Yellow),(Green,Blue),(Green,Green)]
</pre>


<p>
Let&rsquo;s define another color type and simply rely on Haskell&rsquo;s
<code>deriving</code> to create instances for <code>Eq</code> and <code>Ord</code> 
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org5b32323"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Color2</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Green2</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Blue2</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Yellow2</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Red2</span> <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span>,<span class="org-haskell-constructor">Read</span>,<span class="org-haskell-constructor">Eq</span>,<span class="org-haskell-constructor">Ord</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="orgac01944"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Red2</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Red2</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-haskell-constructor">Red2</span> <span class="org-haskell-operator">==</span> <span class="org-haskell-constructor">Green2</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
False
</pre>


<p>
For equal-ness <code>deriving</code> simply made everything equal to itself and
not equal to other colors&#x2014;just like we did before by hand. Then for
order-ness <code>deriving</code> simply took the <code>Color2</code> data constructors in
the order they were declared and ranked them in ascending order
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org53652d1"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Green2</span> <span class="org-haskell-operator">&lt;</span> <span class="org-haskell-constructor">Blue2</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">==</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-constructor">Blue2</span> <span class="org-haskell-operator">&lt;</span> <span class="org-haskell-constructor">Yellow2</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">==</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Yellow2</span> <span class="org-haskell-operator">&lt;</span> <span class="org-haskell-constructor">Red2</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>
</div>
<div id="outline-container-org52569d6" class="outline-5">
<h5 id="org52569d6">Types of types</h5>
<div class="outline-text-5" id="text-org52569d6">
<p>
We should explain one more thing at this point, namely, what that
first line of our <code>:i</code> readouts says
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgf4d1ff3"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Color</span>
</pre>
</div>

<pre class="example" id="orgb2581f5">
: type Color :: *
: data Color = Red | Yellow | Blue | Green
:   	-- Defined at omni1.1.hs:29:1
: instance [safe] Eq Color -- Defined at omni1.1.hs:30:10
: instance [safe] Ord Color -- Defined at omni1.1.hs:36:10
: instance [safe] Read Color -- Defined at omni1.1.hs:29:57
: instance [safe] Show Color -- Defined at omni1.1.hs:29:52
</pre>

<p>
<code>type Color :: *</code> is telling us that the <i>type</i> of the type <code>Color</code> is
<code>*</code>. Huh? So if the type of values <code>Red</code> or <code>Green</code> is <code>Color</code>, the
<i>type</i> of <code>Color</code> is it&rsquo;s <i>kind</i>, here expressed by the symbol
<code>*</code>. <font color = "#650d1c"> <code>Color</code> has kind <code>*</code>, which
says <code>Color</code> is a type constructor of <b>arity</b> null, or a <i>nullary</i>
type constructor.</font> So what does this mean? Let&rsquo;s take
it apart&#x2026;
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Arity">Arity</a> is something functions have. \(f(x) = x^2\;\) has an arity of one
since it takes just the one parameter, \(x\). For \(f(x,y) = x^2y^{1/3\;\;}\)
arity is two &#x2014; and we usually say <i>binary</i> since it takes two
parameters, \(x\) and \(y\;\). But \(f() = 5\;\) is a function that takes no
parameters and always returns \(5\;\). It&rsquo;s arity is null<label id='fnr.37' for='fnr-in.37.8661255' class='margin-toggle sidenote-number'><sup class='numeral'>37</sup></label><input type='checkbox' id='fnr-in.37.8661255' class='margin-toggle'><span class='sidenote'><sup class='numeral'>37</sup>
This may be slightly confusing since in Algebra you probably
learned about constant functions expressed as, e.g., \(f(x) = 5\;\),
which is just a horizontal line \(y = 5\) for any \(x\;\) you plug in.
</span>.
</p>

<p>
In the second line, the data type declaration line, we see the left
side of the <code>=</code> is <code>Color</code>, which is the <i>type constructor</i>, and on
the right side are the <i>data constructors</i> or <i>value constructors</i>,
which are <code>Red | Yellow | Blue | Green</code>, which are also referred to as
just the <i>values</i> of <code>Color</code>. Again, the type of <code>Red</code> is <code>Color</code>, and
the type of <code>Color</code> is <code>*</code>, which is Haskell&rsquo;s way of noting <code>Color</code>
has an arity of null. Which is just like \(f() = 5\;\) only that it has
values<label id='fnr.38' for='fnr-in.38.3577937' class='margin-toggle sidenote-number'><sup class='numeral'>38</sup></label><input type='checkbox' id='fnr-in.38.3577937' class='margin-toggle'><span class='sidenote'><sup class='numeral'>38</sup>
If a data constructor (also called <i>value</i> constructor) has a
nullary type constructor, as does <code>Color</code>, then just like with \(f() =
5\) the \(5\) is a <i>constant</i>, and so are the values <code>Red</code>, <code>Yellow</code>, <code>Blue</code>,
<code>Green</code> considered constants.
</span> <code>Red</code>, <code>Yellow</code>, <code>Blue</code>, <b>or</b> <code>Green</code> as possible values
instead of just \(5\). And like \(5\), we can consider them as
constants. Yes, it might be odd to consider a data type as a sort of
function taking parameters, but under Haskell&rsquo;s hood they do. So we
might say <code>Color</code> takes the null parameter and returns one of its
color data constructors as a value. Odd, but that&rsquo;s Haskell.
</p>

<p>
So what would be an example of type with higher arity? What would a
data type look like that had a type constructor on the left side of
<code>=</code> that did in fact take input like a function &#x2014; and what does such
a thing give us?  Consider this data type
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orge57af97"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">StreetShops</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Grant</span> a <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Lee</span> a <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Lincoln</span> a <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Show</span>,<span class="org-haskell-constructor">Read</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
And its kind will look like this
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org1d483d0"><span class="org-haskell-constructor">:</span>k <span class="org-haskell-constructor">StreetShops</span>
</pre>
</div>

<pre class="example">
StreetShops :: * -&gt; *
</pre>


<p>
The form <code>* -&gt; *</code> is Haskell&rsquo;s way of saying the data type
<code>StreetShops</code> indeed takes a single parameter like a function. And
that parameter <code>a</code> is, like before, leveraging parametric
polymorphism, meaning <code>a</code> can be any data type. This in turn makes
<code>StreetShops</code> polymorphic, i.e., its values <code>Grant</code>, <code>Lee</code>, and
<code>Lincoln</code> are able to take input of different data types. For example,
if we want our <code>StreetShops</code> value <code>Grant</code> to represent a list of all
the shops we visit on Grant Street<label id='fnr.39' for='fnr-in.39.4047004' class='margin-toggle sidenote-number'><sup class='numeral'>39</sup></label><input type='checkbox' id='fnr-in.39.4047004' class='margin-toggle'><span class='sidenote'><sup class='numeral'>39</sup>
We&rsquo;ll give data constructor <code>Grant</code> a list of elements of type
<code>String</code>, a Haskell <code>String</code> being, in reality, a <i><a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms">type synonym</a></i> for
list of type <code>Char</code>, which are individual Unicode characters. <br>
<code>λ&gt; "Tre Chic" == ['T','r','e',' ','C','h','i','c']</code> <br>
<code>True</code>
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org8bbe013"><span class="org-haskell-definition">shopsOnGrant</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Grant</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"Tre Chic"</span>,<span class="org-string">"Dollar Chasm"</span>,<span class="org-string">"Gofer Burgers"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org31501e3">shopsOnGrant
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org0a55420"><span class="org-haskell-constructor">:</span>t shopsOnGrant
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-12: error: Variable not in scope: shopsOnGrant
</pre>


<p>
So each of the data constructors can take a parameter <code>a</code>, which can
be anything. If we want a <code>StreetShops</code> value to hold the average
number of visitors per day<label id='fnr.40' for='fnr-in.40.704363' class='margin-toggle sidenote-number'><sup class='numeral'>40</sup></label><input type='checkbox' id='fnr-in.40.704363' class='margin-toggle'><span class='sidenote'><sup class='numeral'>40</sup>
Haskell has great powers of inferring, i.e., when we ask it
what type <code>visitorsOnGrant</code> is, it deduces this from how we created
<code>visitorsOnGrant</code>, namely: <code>visitorsOnGrant :: Num a =&gt; StreetShops a</code>.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd237ecc"><span class="org-haskell-definition">visitorsOnGrant</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Grant</span> 1294
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org4c5d452">visitorsOnGrant
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org70a3ad1"><span class="org-haskell-constructor">:</span>t visitorsOnGrant
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-15: error: Variable not in scope: visitorsOnGrant
</pre>


<p>
Again, <code>StreetShops</code>, by having kind or arity of one, is polymorphic
in its one parameter <code>a</code>.  And in reality there is no <i>just</i>
<code>StreetShops</code> type; instead, <code>StreetShops</code> has to be teamed up with
another type to be used. To be sure, <code>StreetShops</code> is a contrived
example of the <code>* -&gt; *</code> kind. In reality there are probably better
ways of managing data about streets. But we&rsquo;ll certainly use lots of
data types with higher arity, especially when we start going deeper
into some of the more math-derived features in Haskell. And so that&rsquo;s
why we wanted to introduce what may seem pretty abstract at this
point<label id='fnr.41' for='fnr-in.41.2835404' class='margin-toggle sidenote-number'><sup class='numeral'>41</sup></label><input type='checkbox' id='fnr-in.41.2835404' class='margin-toggle'><span class='sidenote'><sup class='numeral'>41</sup>
As another example of introducing an abstract subject out of
the blue and way early, do you remember middle school math trying to
show you commutativity, distributivity, and associativity? Well, they
become important in higher math, especially in abstract
algebra. Haskell has lots of higher algebra baked in, and yes, you&rsquo;ll
finally see a real-world application of commutativity, distributivity,
and associativity soon!
</span>.
</p>
</div>
</div>
<div id="outline-container-orge391aae" class="outline-5">
<h5 id="orge391aae">The <code>Num</code> super class</h5>
<div class="outline-text-5" id="text-orge391aae">
<p>
Did you notice that <code>Num a =&gt;</code> class constraint in the type details of
<code>visitorsOnGrant</code>? When we created the variable <code>visitorsOnGrant</code> we
gave the value constructor <code>Grant</code> a number &#x2014; but we didn&rsquo;t say what
sort of number, <code>Int</code>, <code>Integer</code>, <code>Float</code>&#x2026; Haskell then inferred
that it was something numerical and constrained it with the type class
<code>Num</code>&#x2026;
</p>

<p>
Let&rsquo;s take another look at the concept of class hierarchy. Remember
how we had <code>Eq</code> equal-ness as a prerequisite for <code>Ord</code> order-ness? We
needed equal-ness to then create order-ness. Consider this
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb7be17e"><span class="org-haskell-constructor">:</span>t 1
</pre>
</div>

<pre class="example">
1 :: Num a =&gt; a
</pre>


<p>
This is Haskell&rsquo;s way of saying, Yes, this is some sort of <i>literal</i>
number you gave me. And all I can say back to you is it is a
number. And so the generic parameter <code>p</code> has the class constraint that
whatever <code>p</code> may be (here we provided <code>1</code>), it must be registered with
the type class <code>Num</code>. So what is this <code>Num</code> class?
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org3592cc8"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Num</span>
</pre>
</div>

<pre class="example" id="orgc7eb2b3">
type Num :: * -&gt; Constraint
class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer -&gt; a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Double -- Defined in ‘GHC.Float’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
instance Integral a =&gt; Num (Ratio a) -- Defined in ‘GHC.Real’
</pre>

<p>
Here we see number-ness defined through its methods. Whatever type
might want to be considered a number will need to have these
operations of addition, subtraction, multiplication, negation, etc.,
i.e., register an instance with the <code>Num</code> class<label id='fnr.42' for='fnr-in.42.7279737' class='margin-toggle sidenote-number'><sup class='numeral'>42</sup></label><input type='checkbox' id='fnr-in.42.7279737' class='margin-toggle'><span class='sidenote'><sup class='numeral'>42</sup>
Actually, our example <code>:t 1</code> relies on the method
<code>fromInteger</code>, but we&rsquo;ll unpack that later. Even more actually, a
whole lot of complex magic is going on behind the scenes when dealing
with naked (literal) numbers like this. So yes, this is an example of
LE for doing numbers on computers with programming languages.
</span>.
</p>

<p>
Actually, <code>Num</code> is a great place to start really seeing how
mathematical Haskell is. <code>:i Num</code> gives us good look, but, as we
mentioned before, <a href="https://hackage.haskell.org/">hackage.haskell.org</a>, in this case <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Num.html">GHC.Num</a>.
</p>
</div>
<div id="outline-container-orgc0121f7" class="outline-6">
<h6 id="orgc0121f7">GHC.Num</h6>
<div class="outline-text-6" id="text-orgc0121f7">
<img src="./images/numclass1.png" style="padding: 15px 0px 0px 0px"  alt="Fundamental laws of arithmetic" class="center">
<span class="cap">Fundamental laws of arithetic according to Num</span>

<p>
What is this? Why is this mentioned? A simple starter explanation is
that we have here a set of guidelines for how addition and
multiplication must behave in order to have an instance of
<code>Num</code>. Let&rsquo;s continue&#x2026;
</p>

<p>
So if multiplication is just a glorified sort of addition, and
division is glorified subtraction<label id='fnr.43' for='fnr-in.43.5732047' class='margin-toggle sidenote-number'><sup class='numeral'>43</sup></label><input type='checkbox' id='fnr-in.43.5732047' class='margin-toggle'><span class='sidenote'><sup class='numeral'>43</sup>
Multiplication is often phrased, e.g., &ldquo;five fives,&rdquo; i.e.,
five sets of five are to be considered (read added)
together. Likewise, division "divide \(8\) by \(2\) is just <i>subtract</i> \(2\)
from \(8\) over and over and keep track of how many times you can do
this until there&rsquo;s either nothing left or a number less than \(2\;\).
</span>, then that makes addition and
subtraction the basis of arithmetic, <i>but</i> they have a very
fundamentally different behavior when used in the wild that we must,
in turn, account for. Yes, addition puts things together and
subtraction takes something away from another thing. But there&rsquo;s
further <i>-ness</i> to addition that subtraction doesn&rsquo;t have, namely,
<i>order doesn&rsquo;t seem to matter, whereas it does with subtraction (and
of course division)</i>. Obviously it matters which number gets
subtracted or divided by which, but not with addition and
multiplication.
</p>

<p>
We mentioned <i>binary</i> operators before, which means whenever we add or
subtract we&rsquo;re really taking just two numbers at a time<label id='fnr.44' for='fnr-in.44.9130669' class='margin-toggle sidenote-number'><sup class='numeral'>44</sup></label><input type='checkbox' id='fnr-in.44.9130669' class='margin-toggle'><span class='sidenote'><sup class='numeral'>44</sup>
Think about it, even when you&rsquo;ve got a whole list (vertical or
horizontal) of numbers to add, you&rsquo;re really doing them two at a
time. One number becomes the <i>addend</i> and the other becomes the
<i>augend</i>, which is sort of a carrying-over holder to which the next
addend is added. So if we&rsquo;re adding \(1 + 2 + 5\;\) we might add \(1 + 2\;\)
and then remember the augend is \(3\;\), then take addend \(5\) and add it
to augend \(3\) to get \(8\;\).
</span>, i.e.,
the arity of the <code>(+)</code> operator is two, or <code>(+)</code> is a <i>binary</i>
operation. But again, why are we concerned with this?
</p>

<p>
Notice at <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Num.html">GHC.Num</a> it says
</p>

<blockquote>
<p>
The Haskell Report defines no laws for <code>Num</code>. However, (+) and (*) are
customarily expected to define a ring and &#x2026;
</p>
</blockquote>

<p>
The Haskell Report is a reference manual for how Haskell is put
together, often just showing us how certain pieces of the language are
coded under the hood. Typically, you see a Backus-Naur
description<label id='fnr.45' for='fnr-in.45.7949751' class='margin-toggle sidenote-number'><sup class='numeral'>45</sup></label><input type='checkbox' id='fnr-in.45.7949751' class='margin-toggle'><span class='sidenote'><sup class='numeral'>45</sup>
More on Backus–Naur Form later. It&rsquo;s used extensively to
create a <a href="https://en.wikipedia.org/wiki/Metasyntax">metasyntax</a> for programming languages. Maybe rabbit-hole <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">this
Wikipedia treatment</a>.
</span>, then some description/talk, maybe also examples
and &ldquo;translations<label id='fnr.46' for='fnr-in.46.7102397' class='margin-toggle sidenote-number'><sup class='numeral'>46</sup></label><input type='checkbox' id='fnr-in.46.7102397' class='margin-toggle'><span class='sidenote'><sup class='numeral'>46</sup>
Try Haskell&rsquo;s <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11">list comprehension</a>. Don&rsquo;t expect to understand
what they&rsquo;re saying just yet, but appreciate the magic and all the
devilish details. And while you&rsquo;re at it you might further appreciate
just what a list comprehension is by looking at <a href="https://rosettacode.org/wiki/List_comprehensions">this Rosetta Code
article</a>. Again, YMMV on what you can grasp at this point, but maybe
notice how Haskell is <i>very</i> <a href="https://en.wikipedia.org/wiki/Set-builder_notation">Set-builder notation</a>-friendly, while
other languages just seem to be kludging something together. Again,
maybe a bit too advanced, but check out <a href="https://rosettacode.org/wiki/List_comprehensions#Haskell">Haskell&rsquo;s entry</a> for the
Pythagorean triplets. Experiment with the code. A big part of learning
to program is to read and experiment with code.
</span>.&rdquo;  GHC.Num says there is no particular
mention in the HR of these arithmetical laws, but <code>(+)</code> and <code>(*)</code>
should <i>define a ring</i>. So here the lore is getting deep. What is
meant by a <i>ring</i><label id='fnr.47' for='fnr-in.47.7179767' class='margin-toggle sidenote-number'><sup class='numeral'>47</sup></label><input type='checkbox' id='fnr-in.47.7179767' class='margin-toggle'><span class='sidenote'><sup class='numeral'>47</sup>
Have a look at <a href="https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Applied_Discrete_Structures_(Doerr_and_Levasseur)/16%3A_An_Introduction_to_Rings_and_Fields/16.01%3A_Rings_Basic_Definitions_and_Concepts">this LibreText explanation</a> but don&rsquo;t try it
without first getting through the basic set theory stuff in the
assigned rabbit-hole.
</span>? Well, a ring is something from abstract
algebra, which you&rsquo;ll see in a mathematics curriculum once you&rsquo;re
beyond Frosh college math including calculus, differential equations,
and linear algebra. The basic idea is that a ring is a <i>set</i>
containing a <i>set</i> of numbers, along with key arithmetical operators
behaving in certain ways. In other words, a ring is a sort of like a
package which includes numbers and the operations that work on those
numbers. Then neatly bundled like this, we can do and say things about
them as a whole. But let&rsquo;s leave it at that for now. We&rsquo;ll soon
explore other similar &ldquo;packagings&rdquo; (semigroups, monoids, etc.) from
abstract algebra that are brought over for use in Haskell.
</p>

<p>
Continuing, if the so-called <i>fundamental laws of arithmetic</i><label id='fnr.48' for='fnr-in.48.4627558' class='margin-toggle sidenote-number'><sup class='numeral'>48</sup></label><input type='checkbox' id='fnr-in.48.4627558' class='margin-toggle'><span class='sidenote'><sup class='numeral'>48</sup>
&#x2026;taken from Richard Courant&rsquo;s seminal <i>What is Mathematics?</i>
</span> say
</p>

<ol class="org-ol">
<li>\(a + b = b + a\quad\) (additive commutativity, AC)</li>
<li>\(ab = bc\quad\) (multiplicative commutativity, MC)</li>
<li>\(a + (b + c) = (a + b) + c\quad\) (additive associativity, AA)</li>
<li>\(a(bc) = (ab)c\quad\) (multiplicative associativity, MA)</li>
<li>\(a(b + c) = ab + ac\quad\) (distributive law, DL)</li>
</ol>

<p>
then in order to have &ldquo;number-ness&rdquo; a <code>Num</code> instance for a number type
should have these behaviors when added or multiplied. But if we
compare, these <i>five</i> laws concerning addition and multiplication
aren&rsquo;t exactly the same as those Haskell laws mentioned above from
GHC.Num. For one, Where&rsquo;s #2, multiplicative commutativity, i.e., \(ab
= bc\;\)? It turns out not everything has MC; hence, we don&rsquo;t want to
be obligated to defining MC for everything. An example is when
multiplying matrices. Maybe we&rsquo;re not that far, but no, matrix
multiplication does not guarantee \(ab = bc\;\). Another potential
divergence is <i>additive inverse</i> and <i>multiplicative inverse</i>. These
should be defined on any type wanting to join the <code>Num</code> class. More on
that later.
</p>

<p>
\(\mathfrak{Fazit}\;\): <code>Num</code> is a super-class that is a prerequisite
&ldquo;constraint&rdquo; for anything number-like in Haskell. And so any type with
which we want to do basic arithmetic, i.e., to have number-ness, must
register an instance with the type class <code>Num</code>, defining the minimum
set of methods in order to perform basic math operations.
</p>


<p>
This has been a brief, hurried introduction to ordinality &#x2014; with a
small detour to explore some of the LE of what numbers are vis-à-vis
Haskell and computers. The notion of order is everywhere and cannot be
taken for granted. And the idea of ordinality goes pretty deep in
higher math. See <a href="https://en.wikipedia.org/wiki/Ordered_field">this</a> and <a href="https://math.libretexts.org/Bookshelves/Analysis/Introduction_to_Mathematical_Analysis_I_(Lafferriere_Lafferriere_and_Nguyen)/01%3A_Tools_for_Analysis/1.04%3A_Ordered_Field_Axioms">this</a> fire hose treatments as somewhere
between R<sub>O</sub> and R<sub>FYI</sub>. (And see <a href="https://en.wikipedia.org/wiki/Ordinal_number#Von_Neumann_definition_of_ordinals">this</a> for something we&rsquo;ll eventually take
a Haskell stab at.) Note especially the <i>order axioms</i> and the
<i>properties of ordered fields</i>. In general, these treatments are
upper-level/grad math &#x2014; or, yes, upper-level comp-sci, depending on
your future school&rsquo;s program. Remember, comp-sci dips and weaves
around and through higher math with little or no warning &#x2014; a bit
like physics routinely takes off into high math-land as well.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org507ae8f" class="outline-3">
<h3 id="org507ae8f">Enumeration, counting, listing out</h3>
<div class="outline-text-3" id="text-org507ae8f">
<p>
Enumeration is counting is enumeration. And yet they seem like
different tasks. To count something seems like a dynamic process. We
take objects out of a box and <i>count</i> how many there are. To enumerate
would seem to be more about taking objects out one-by-one and &ldquo;giving
each a number.&rdquo;
</p>

<p>
But in the field of combinatorics the business of
counting-enumerating goes far beyond taking objects out of a box and
associating numbers with them. We could say &ldquo;listing out&rdquo; for
enumeration, and there are very many phenomena that have very deep,
very complex listings outs.
</p>

<p>
With sets the simplest way to have a set is to literally name each
element one by one. This is considered enumeration as well. Then
there&rsquo;s the use of ellipses (&#x2026;) to indicate we want elements &ldquo;filled
out&rdquo; according to some scheme we&rsquo;re following. But this can run into
ambiguities. For example \(\{1,2,3,\ldots\}\;\) could be just a listing
of the counting numbers, or it might be the <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci sequence</a> where
each new number (beyond the first two) is the previous two added
together, i.e., \(\{1,2,3,5,8,13\ldots\}\;\;\).
</p>
</div>
<div id="outline-container-orgde717ef" class="outline-4">
<h4 id="orgde717ef">Induction</h4>
<div class="outline-text-4" id="text-orgde717ef">
<p>
Filling out or enumerating a set often rests on the concept of
<i>induction</i>.
</p>
</div>
</div>
<div id="outline-container-orgb9d5ff6" class="outline-4">
<h4 id="orgb9d5ff6">Enumeration in Haskell</h4>
<div class="outline-text-4" id="text-orgb9d5ff6">
<p>
The most basic enumeration in Haskell is filling a range of numbers.
</p>
</div>
</div>
</div>
</section>
<section id="outline-container-org0e5a331" class="outline-2">
<h2 id="org0e5a331">Numbers as algebraic systems</h2>
<div class="outline-text-2" id="text-org0e5a331">
<p>
Conceptually, our &ldquo;starter set&rdquo; of numbers, the so-called <i>natural
numbers</i> or <i>counting numbers</i><label id='fnr.49' for='fnr-in.49.1065177' class='margin-toggle sidenote-number'><sup class='numeral'>49</sup></label><input type='checkbox' id='fnr-in.49.1065177' class='margin-toggle'><span class='sidenote'><sup class='numeral'>49</sup>
Group of things are considered <i>countable</i> if we can create a
one-to-one relationship between the things and the counting numbers,
which typically should start with \(1\;\). Things in everyday life are
typically countable; but what about <i>all</i> the points on the real
number line?
</span>, symbolized by \(\mathbb{N}\;\), are not
hard to imagine. You&rsquo;ve been using them since Kindergarten where you
connected the numeral symbols, \(1,2,3\ldots\;\) and names, \(one, two,
three\ldots\;\) of numbers with amounts of things. Then we moved on to
doing arithmetic with these counting numbers; first stop, addition.
</p>

<p>
<i>Addition</i> was never a problem with the natural numbers, i.e.,
whatever from \(\mathbb{N}\) we wanted to add together would result in
just another member of \(\mathbb{N}\;\). And since multiplication is
just a glorified form of addition, we&rsquo;re safe there, too. But what
happens when we try to subtract and divide with members of
\(\mathbb{N}\;\)?  Clearly, we need to expand our starter set to deal
with answers that lie outside of the positive natural numbers. For
subtraction we need a new set, namely, the <i>integers</i>
\(\mathbb{Z}\;\)<label id='fnr.50' for='fnr-in.50.4693705' class='margin-toggle sidenote-number'><sup class='numeral'>50</sup></label><input type='checkbox' id='fnr-in.50.4693705' class='margin-toggle'><span class='sidenote'><sup class='numeral'>50</sup>
From the LibreTexts rabbit hole, think of \(\mathbb{Z}\) as
everything in \(\mathbb{N}\) along with the negative version of all of
\(\mathbb{N}\;\), i.e., \(\mathbb{Z} =
\{\ldots,-3,-2,-1,0,1,2,3,\ldots\}\)
</span>. As you saw in the first rabbit hole above,
mathematics takes a more formal approach to issues like this. In fact,
there are five main groups of numbers:
</p>

<ul class="org-ul">
<li>\(\mathbb{N}\;\): Natural numbers.</li>
<li>\(\mathbb{Z}\;\): Integers.</li>
<li>\(\mathbb{Q}\;\): Rational numbers.</li>
<li>\(\mathbb{R}\;\): Real numbers.</li>
<li>\(\mathbb{C}\;\): Complex numbers</li>
</ul>

<p>
which we will study in turn. We mention numbers in the context of
algebraic systems because
</p>
</div>
</section>
<section id="outline-container-org981c191" class="outline-2">
<h2 id="org981c191">Natural numbers</h2>
<div class="outline-text-2" id="text-org981c191">
<ul class="org-ul">
<li><a href="http://cmsc-16100.cs.uchicago.edu/2015/Notes/arithmetic.php">http://cmsc-16100.cs.uchicago.edu/2015/Notes/arithmetic.php</a></li>
<li><a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano axioms</a></li>
</ul>
</div>
<div id="outline-container-org99d8dc0" class="outline-3">
<h3 id="org99d8dc0">The natural numbers are the counting numbers</h3>
<div class="outline-text-3" id="text-org99d8dc0">
<p>
Taking a stab at a word definition of \(\mathbb{N}\) in a quasi-set notation style
</p>

\begin{align*}
\mathbb{N} = \{\text{all the whole numbers starting with zero}\}
\end{align*}

<p>
But what do we mean by <i>all</i> and <i>starting with</i>?  For example, is
there any order<label id='fnr.51' for='fnr-in.51.7085189' class='margin-toggle sidenote-number'><sup class='numeral'>51</sup></label><input type='checkbox' id='fnr-in.51.7085189' class='margin-toggle'><span class='sidenote'><sup class='numeral'>51</sup>
The order of a group of things is its <i>ordinality</i>, while the
number of a collection of things is its <i>cardinality</i>.
</span> implied, or are these whole numbers just in
whatever order as long as they&rsquo;re <i>after</i> zero? Of course our
intuitive understanding of what counting numbers are saves us from
silly hypothetical questions like this, right?
</p>

<p>
At some point around that Kindergarten time we wandered into our first
serious mathematical abstraction when we learned about numbers that
have two &ldquo;places&rdquo; or more: ten, eleven, twelve, then the teens, then
twenties, thirties &#x2026; on out to hundreds, and then even
thousands. This required an understanding of <i>positional
notation</i><label id='fnr.52' for='fnr-in.52.95192' class='margin-toggle sidenote-number'><sup class='numeral'>52</sup></label><input type='checkbox' id='fnr-in.52.95192' class='margin-toggle'><span class='sidenote'><sup class='numeral'>52</sup>
See <a href="https://en.wikipedia.org/wiki/Positional_notation">Positional notation</a>.
</span> using the ten base<sub>10</sub> Arabic numerals, \(0\) to \(9\),
and placing them in increasing powers-of-ten columns. But this was all
done at an intuitive level meant to cement in our minds the
fundamental idea that distinct <i>amounts</i> have distinct designations,
i.e., names and numeric symbols. We weren&rsquo;t expected to understand the
underlying idea of <i>positional notation</i>.
</p>

<p>
But seriously, how can we indicate five things without the numerical
symbol \(5\) or the words <i>five</i> or <i>fifth</i>? We might imitate an old
mechanical watch and bark out <i>tick!</i> five times<label id='fnr.53' for='fnr-in.53.7338460' class='margin-toggle sidenote-number'><sup class='numeral'>53</sup></label><input type='checkbox' id='fnr-in.53.7338460' class='margin-toggle'><span class='sidenote'><sup class='numeral'>53</sup>
My mechanical pocket watch has a face with Roman numerals
evenly positioned around a circle, twelve main numbers for the hours
with little marks between each number for the minutes and seconds. But
internally, the mechanics only know about ticking; they know nothing
of the numbers and their positions on the watch face. This means the
steady ticking is <i>mapped</i> to the watch face dumbly. Is ticking,
therefore, the most fundamental sort of counting? When combined with a
number display, perhaps.
</span>, hoping that
someone is keeping track of how many ticks there were. But there&rsquo;s the
rub: the whole idea of counting relies on some sort of ordering and
enumeration scheme&#x2014;right, keeping track. So five of something
implies one more than four of something, which in turn implies two
more than three things, et cetera. 
</p>
</div>
</div>
<div id="outline-container-orgb8357f7" class="outline-3">
<h3 id="orgb8357f7">Peano&rsquo;s approach to the natural numbers</h3>
<div class="outline-text-3" id="text-orgb8357f7">
<ul class="org-ul">
<li>baader1999term</li>
</ul>

<p>
The nineteenth century saw mathematics going through an intense round
of mathematical formalism and exactness. Mathematicians wanted to firm
up the underpinnings of math, clean up sloppy, intuitive, hand-waving
half-understandings and put math on solid, unassailable logical
footing. One such mathematician was Giuseppe Peano.
</p>

<p>
At issue was just what were those most basic mathematical building
blocks, the counting numbers? Sure, there&rsquo;s the Kindergarten version
of \(\mathbb{N}\;\), but was there something foundational underneath
just rattling off numbers like a child? After all, that&rsquo;s not much
different from circus animal training.
</p>

<p>
Let&rsquo;s warm up by considering what we said in the last section about
\(5\) being what came after \(4\), which in turn came after \(3\) and so
on. In effect we&rsquo;ve got one number <i>succeeding</i> another. Hence, in
theory at least, we could start at \(0\;\) and then literally <i>succeed</i>
our way up to any number we want, which is like saying every journey
starts with a first step, followed by the next step, then the next,
etc. Again, this may seen trivial-silly, but there&rsquo;s a lot of math
packed in this concept.
</p>
</div>
<div id="outline-container-org6490140" class="outline-4">
<h4 id="org6490140">A first stab at a formalization</h4>
<div class="outline-text-4" id="text-org6490140">
<ul class="org-ul">
<li>baader1999term</li>
</ul>

<p>
Later we&rsquo;ll go into a more detail about what a function really is, but
for now our basic understanding of functions will do. So let&rsquo;s bring
to the idea of one thing succeeding another a <i>successor function</i>
\(s(n)\;\). For example, if we start at \(0\), the successor to \(0\) is
\(1\;\), or \(s(0) = 1\;\). But if we&rsquo;re going to be highly abstract and
pure about this, we don&rsquo;t want to rely on the base\(_{10}\)
numbers. Instead, we&rsquo;ll just keep reapplying the successor function
\(S\;\) similar to nesting Russian dolls<label id='fnr.54' for='fnr-in.54.6552547' class='margin-toggle sidenote-number'><sup class='numeral'>54</sup></label><input type='checkbox' id='fnr-in.54.6552547' class='margin-toggle'><span class='sidenote'><sup class='numeral'>54</sup>
Russian or <i>matryoshka</i> dolls: <br>
<img src="images/russiandolls.png" alt="russiandolls.png">  <br>
<br>
</span>
</p>

\begin{align*}
0 &= 0 \\
1 &= S(0) \\
2 &= S(S(0)) \\
3 &= S(S(S(0))) \\
4 &= S(S(S(S(0)))) \\
\ldots
\end{align*}

<p>
Awkward? YMMV<label id='fnr.55' for='fnr-in.55.9962660' class='margin-toggle sidenote-number'><sup class='numeral'>55</sup></label><input type='checkbox' id='fnr-in.55.9962660' class='margin-toggle'><span class='sidenote'><sup class='numeral'>55</sup>
Your mileage may vary&#x2026;
</span>. But we have to admit we&rsquo;ve defined something akin
to the natural numbers using just the constant \(0\) and a successor
function applied to it. Now, let&rsquo;s define addition on this system. To
do this we&rsquo;ll use these two <i>identities</i>
</p>

\begin{align}
x + 0 &= x \\
x + s(y) &= s(x + y)
\end{align}

<p>
This should cover all possible cases of addition. Testing, let&rsquo;s add
\(1\) and \(2\;\) or \(s(0) + s(s(0))\;\)
</p>

\begin{align}
s(0) + s(s(0)) &= \\
s(s(0) + s(0)) &= \\
s(s(s(0)) + 0) &= s(s(s(0)))
\end{align}

<ul class="org-ul">
<li>We apply (2) to (3) to get (4); in effect abstracting \(1+2\;\), the
left side of (2), to the <i>successor</i> of \(1+1\;\), the right side of
(2).</li>
<li>But now the inner part of (4), namely \(s(0) + s(0)\;\), resembles (2)
allowing us to match the first \(s(0)\) to \(x\) and the second to
\(s(y)\), which in turn allows us to rewrite it as \(s(s(0) +
  0)\;\).</li>
<li>But according to (1) \(s(0) + 0 = s(0)\;\;\), leaving \(s(s(0))\;\)</li>
<li>Including back in the outermost \(s\) we now have \(s(s(s(0)))\;\) our
answer.</li>
</ul>


<p>
What have we accomplished with this convoluted method? For one, we&rsquo;ve
reduced the entire idea of the natural numbers, along with adding two
of these reimagined natural numbers, to just a small set of symbols,
namely
</p>

<ul class="org-ul">
<li>a <i>constant</i> symbol \(0\)</li>
<li>variable symbols \(x\) and \(y\)</li>
<li>and a function symbol \(s\)</li>
</ul>

<p>
And with these four symbols we create statements made of <i>terms</i> built
from our symbols as in (1) and (2), e.g., \(x + 0\;\) is term, and
\(s(x + y)\;\) is another term. This allows us to state our problem as
terms, then <i>rewrite</i> these terms step-by-step as we did above to get
to a final term rewrite that is our answer. And so we have a <i>term
rewriting system</i> that provides addition of our natural
numbers<label id='fnr.56' for='fnr-in.56.989847' class='margin-toggle sidenote-number'><sup class='numeral'>56</sup></label><input type='checkbox' id='fnr-in.56.989847' class='margin-toggle'><span class='sidenote'><sup class='numeral'>56</sup>
Rewriting is basically what you do when you, e.g., take steps
to simplify or reduce a fraction. More on <i>normal</i> or <i>canonical</i>
forms later.
</span>. As Madhavan Mukund says<label id='fnr.57' for='fnr-in.57.8120392' class='margin-toggle sidenote-number'><sup class='numeral'>57</sup></label><input type='checkbox' id='fnr-in.57.8120392' class='margin-toggle'><span class='sidenote'><sup class='numeral'>57</sup>
mukund2009lecture
</span> 
</p>

<blockquote>
<p>
In a sense, rewriting is at the heart of all formulations of
computability &#x2014; any computational device&rsquo;s fundamental behaviour is
to read symbols and generate other symbols, which amounts to rewriting
the input as the output.
</p>
</blockquote>

<p>
So what&rsquo;s the alternative? Your modern digital computer creates a
human-friendly world of numbers and addition with the help of base\(_{2}\)
binary numbers, computer circuit board logic gates, and lots and lots
of Assembler code to manage it all. Then come the higher languages
which present math as we normally see it, e.g., \(1 + 1 = 2\;\). When
seen in this light, we might begin to appreciate a very basic,
fundamental fact about modern computing, namely, <font color =
"#4715b3">we can create strategies to accomplish logical
calculations by manipulating (rewriting) <i>terms</i> built of
<i>symbols</i>.</font> Again, this adds a whole new dimension to
our age-old math world mix of scrolls, paper, books, pencils,
blackboards and chalk, and those mysterious mental representations of
math inside our human brains.
</p>
</div>
</div>
<div id="outline-container-org18d96bc" class="outline-4">
<h4 id="org18d96bc">A first look at induction and recursion<label id='fnr.58' for='fnr-in.58.82138' class='margin-toggle sidenote-number'><sup class='numeral'>58</sup></label><input type='checkbox' id='fnr-in.58.82138' class='margin-toggle'><span class='sidenote'><sup class='numeral'>58</sup>
At this point we can say induction and recursion (and
recurrence relations in general) are just two sides of the same
coin. Make sure you&rsquo;ve got this <a href="http://learnyouahaskell.com/recursion">LYAHFGG&rsquo;s Recursion</a> chapter under your
belt.
</span></h4>
<div class="outline-text-4" id="text-org18d96bc">
<ul class="org-ul">
<li>doets2012haskell</li>
</ul>

<img src="./images/fallingdominoes.png" width="725px" style="padding: 15px 0px 0px 0px" alt="Induction example: dominoes falling" class="center">
<span class="cap">Example of induction: if one domino falls, so will the next.</span>

<p>
Simplistic as our natural number system in the previous section may
seem, there&rsquo;s actually quite a bit of math theory to unpack to really
understand what just happened. When we build a number up from repeated
or nested application of the successor function \(s\) we were using the
ideas of <i>induction</i> and <i>recursion</i><label id='fnr.59' for='fnr-in.59.1140223' class='margin-toggle sidenote-number'><sup class='numeral'>59</sup></label><input type='checkbox' id='fnr-in.59.1140223' class='margin-toggle'><span class='sidenote'><sup class='numeral'>59</sup>
You may or may not have encountered induction. Typically, a
math course will introduce it as a proof strategy.
</span>.
</p>

<p>
Again, this may seem very simplistic, but the idea of induction is
inherent to the natural numbers. So if \(\mathbb{N}\;\) is also referred
to as the counting numbers, then we count or <i>enumerate</i> things with
them&#x2014;going up as high as we need to
</p>

<table id="orgf6943ce">
<caption class="t-bottom"><span class="table-number">Table 1:</span> Enumeration of the first ten primes</caption>

<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
<td class="org-right">8</td>
<td class="org-right">9</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
<td class="org-right">11</td>
<td class="org-right">13</td>
<td class="org-right">17</td>
<td class="org-right">19</td>
<td class="org-right">23</td>
<td class="org-right">29</td>
</tr>
</tbody>
</table>

<p>
Let&rsquo;s make a quick look-up table in Haskell for Table 1
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org293f620">
<span class="org-haskell-definition">primeEnum</span> n <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">&lt;</span> 11<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-1">(</span>n <span class="org-haskell-operator">&gt;</span> 0<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">case</span> <span class="org-rainbow-delimiters-depth-1">(</span>n<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-keyword">of</span>
                          1  <span class="org-haskell-operator">-&gt;</span> 2
                          2  <span class="org-haskell-operator">-&gt;</span> 3
                          3  <span class="org-haskell-operator">-&gt;</span> 5
                          4  <span class="org-haskell-operator">-&gt;</span> 7
                          5  <span class="org-haskell-operator">-&gt;</span> 11
                          6  <span class="org-haskell-operator">-&gt;</span> 13
                          7  <span class="org-haskell-operator">-&gt;</span> 17
                          8  <span class="org-haskell-operator">-&gt;</span> 19
                          9  <span class="org-haskell-operator">-&gt;</span> 23
                          10 <span class="org-haskell-operator">-&gt;</span> 29
            <span class="org-haskell-operator">|</span> otherwise <span class="org-haskell-operator">=</span> error <span class="org-string">"We only know the first ten primes."</span>
            
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="orgc315c0d"><span class="org-haskell-definition">primeEnum</span> 9
</pre>
</div>

<pre class="example">
23
</pre>


<p>
Mathematicians abstracted &ldquo;the next one&rdquo; by saying for any \(n \in
\mathbb{N}\;\), there will be a \(n+1 \in \mathbb{N}\;\;\) &ldquo;next one after
\(n\;\)&rdquo;. Myriad phenomena in life and math lend themselves to this
&ldquo;if you&rsquo;ve got this one, you can get next one&rdquo; idea.
</p>

<p>
𝖟𝕭<label id='fnr.60' for='fnr-in.60.8894374' class='margin-toggle sidenote-number'><sup class='numeral'>60</sup></label><input type='checkbox' id='fnr-in.60.8894374' class='margin-toggle'><span class='sidenote'><sup class='numeral'>60</sup>
<b>zB</b>: German abbreviation for <i>zum Beispiel</i>, or for example.
</span>: A classic proof using mathematical induction is the
proposition<label id='fnr.61' for='fnr-in.61.7068879' class='margin-toggle sidenote-number'><sup class='numeral'>61</sup></label><input type='checkbox' id='fnr-in.61.7068879' class='margin-toggle'><span class='sidenote'><sup class='numeral'>61</sup>
Propositions are statements or assertions that can be proven
to be either true or false. Make sure you went down <a href="https://math.libretexts.org/Courses/Monroe_Community_College/MTH_220_Discrete_Math/2%3A_Logic/2.1%3A_Propositions">this rabbit hole</a>.
</span>
</p>

\begin{align*}
P(n) = 0 + 1 + 2 + 3 + \ldots + n = \frac{n(n+1)}{2}
\end{align*}

<p>
To be clear, we&rsquo;re not <i>deriving</i> this formula<label id='fnr.62' for='fnr-in.62.4968673' class='margin-toggle sidenote-number'><sup class='numeral'>62</sup></label><input type='checkbox' id='fnr-in.62.4968673' class='margin-toggle'><span class='sidenote'><sup class='numeral'>62</sup>
The story behind this formula is interesting. See <a href="https://letstalkscience.ca/educational-resources/backgrounders/gauss-summation">this</a> for the
backstory. Note the formula is <br>
\begin{align*}
\frac{\text{(number of pairs)} &sdot; \text{(sum of each pair)}}{2}
\end{align*} <br>
</span>, we&rsquo;re
attempting to <i>prove</i> it. So for example if we add the first three
numbers, according to the formula we should get \(6\;\)
</p>

\begin{align*}
\frac{(3)(3+1)}{2} = \frac{(12)}{2} = 6
\end{align*}

<p>
An induction proof is a two-step process: a <i>base case</i> and an
<i>induction step</i>
</p>

<p>
<b>Base case</b>: \(P(0)\)
</p>

<p>
\(P(0)\;\) is trivial. Just plug in \(0\)
</p>

\begin{align*}
\frac{(0)(0+1)}{2} = \frac{(0\cdot1)}{2} = 0
\end{align*}

<p>
<b>Inductive step</b>: Now we have to consider \(n \gt 0\;\) cases. The whole
idea is to show that for any number \(k \ge 0\;\), if \(P(k)\;\) works, so
will \(P(k+1)\;\)
</p>

<p>
We start by assuming what is called the <i>induction hypothesis</i>, i.e.,
that our statement \(P\) will hold for \(P(n)\;\). Here we&rsquo;re saying for
the unique case when \(n = k\;\) that \(P(k)\;\) is true
</p>

\begin{align}
0 + 1 + 2 + \ldots + k = \frac{k(k+1)}{2}
\end{align}

<p>
Good. Now we want to consider \(P(k+1)\;\). We&rsquo;ll just add it on both
sides since it is the next step after \(k\;\)
</p>

\begin{align*}
(0 + 1 + 2 + \ldots + k) + (k + 1) = \frac{k(k+1)}{2} + (k+1)
\end{align*}

<p>
Now, we consider just the right side of this equation and do some
algebraic manipulation
</p>

\begin{align*}
\frac{k(k+1)}{2} + (k+1) &= \frac{k(k+1)}{2} + \frac{2(k+1)}{2} \\
                         &= \frac{k(k+1)+2(k+1)}{2}
                         &= \frac{(k+1)(k+2)}{2}
                         &= \frac{(k+1)((k+1)+1)}{2}  
\end{align*}

<p>
Going back to our original left-hand side
</p>

\begin{align}
(0 + 1 + 2 + \ldots + k) + (k + 1) = \frac{(k+1)((k+1)+1)}{2}
\end{align}

<p>
Now, compare (6) with (7). On the left-hand side of (7) we have the
next step \((k+1)\;\) and on the right-hand side of (7) we have in the
numerator the &ldquo;number of pairs&rdquo; increased from \(k\;\) to \(k+1\;\) and
the &ldquo;sum of each pair&rdquo; likewise increased by \(1\;\) from \(k+1\) to \(k +
1 + 1\;\). Through algebraic manipulation we have proved that &ldquo;the next
one&rdquo; will indeed increase as we might want it to. For example, if we
total the first ten numbers
</p>

\begin{align*}
\text{Total sum} = \frac{10 \cdot 11}{2}
\end{align*}

<p>
and totalling the next number \(11\) will just be
</p>

\begin{align*}
\text{Total sum} = \frac{11 \cdot 12}{2}
\end{align*}

<p>
which is covered in our proof for <i>any</i> \(k+1\;\).
</p>
</div>
</div>
<div id="outline-container-org1f5b488" class="outline-4">
<h4 id="org1f5b488">The &ldquo;missing number&rdquo; question</h4>
<div class="outline-text-4" id="text-org1f5b488">
<p>
We&rsquo;ll do a Haskell example where Gauss&rsquo; summing formula will be of
use.
</p>

<p>
<font color = "#4715b3">
⇲ In a sequence on natural numbers \(1 \ldots n\;\) one of the numbers \(k\;\)
is missing, e.g., \(1, \ldots, k-1, k+1, \ldots, n\;\). Find which
number it is.
</font>
</p>

<p>
If we have a relatively short list we can no doubt spot it, e.g.,
\(1,2,4,5\;\); obviously \(3\;\) is missing. But what if our sequence is
thousands of numbers long. For example, with Haskell&rsquo;s list completion
we can create a list representing a very big sequence
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org061fabc"><span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>100<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]
</pre>


<p>
Still doable, but for a sequence going from \(1\) to \(1,000\) it would be
hard to spot the missing number. One solution would be to recurse
through the list testing each number that it was the next after the
previous
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orga4e0783"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">missingNumberGen</span> n m <span class="org-haskell-operator">|</span> 
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="org3064c8a"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">missingTest1</span> xs
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb750b96" class="outline-4">
<h4 id="orgb750b96">Recurrence relations</h4>
<div class="outline-text-4" id="text-orgb750b96">
<ul class="org-ul">
<li>enwiki:1087878116</li>
</ul>














<p>
For example, what if we add up the first three
consecutive odd numbers
</p>

<p>
Peano postulated <i>axioms</i>,
givens, starting points. Using set theory methods, he attempted to 
</p>

<p>
According to a modern treatment, there are five basic Peano axioms<label id='fnr.63' for='fnr-in.63.2838594' class='margin-toggle sidenote-number'><sup class='numeral'>63</sup></label><input type='checkbox' id='fnr-in.63.2838594' class='margin-toggle'><span class='sidenote'><sup class='numeral'>63</sup>
Peano actually had nine axioms; however, four of these deal
with the equality of his natural numbers, which we&rsquo;ll deal with later
when we explore <i>relations</i>, a more general concept above functions.
</span>. The
first axiom states
</p>

<ol class="org-ol">
<li><font color = "#4715b3">\(0\) is a natural number, i.e., \(0
   \in \mathbb{N}\) </font></li>
</ol>

<p>
This is our starting point. Peano then gives four axioms to establish
<i>equality</i>
</p>

<ol class="org-ol">
<li value="2"><font color = "#4715b3"> For every natural number
\(n\), \(S(n)\;\) is a natural number. That is, the natural numbers
are closed under \(S\;\). Or \(x \in \mathbb{N} \rightarrow Sx \in \mathbb{N}\;\;\).
</font></li>
</ol>


<ol class="org-ol">
<li><font color = "#4715b3">For all natural numbers x and y, if x = y, then y = x. That is, equality is symmetric.</font>
<ol class="org-ol">
<li></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org44acc09" class="outline-3">
<h3 id="org44acc09">Closures</h3>
<div class="outline-text-3" id="text-org44acc09">
<p>
From the <i>LibreTexts series</i> on Discrete Mathematics, we saw the
concept of <i><a href="https://math.libretexts.org/Courses/Monroe_Community_College/MTH_220_Discrete_Math/1%3A_Introduction_to_Discrete_Mathematics/1.5%3A_Introduction_to_Sets_and_Real_Numbers">sets</a></i> and how they formalize our ideas about
numbers. Again, think of the <i>set</i> of natural numbers. In set notation
we can list just a few <i>consecutive</i>, <i>distinct</i> numbers, then rely on
ellipses, (&#x2026;), to indicate &ldquo;continue with this consecutive, distinct
number pattern&rdquo;
</p>

\begin{align*}
\mathbb{N} = \{0,1,2,3,\ldots \}
\end{align*}

<p>
This is a more abstract and probably more precise set notation for
\(\mathbb{N}\;\) than the previous word-based one. But again we&rsquo;re
assuming ordinality without actually defining it. And notice how our
\(\mathbb{N}\;\) depiction contains no negative numbers<label id='fnr.64' for='fnr-in.64.9339368' class='margin-toggle sidenote-number'><sup class='numeral'>64</sup></label><input type='checkbox' id='fnr-in.64.9339368' class='margin-toggle'><span class='sidenote'><sup class='numeral'>64</sup>
Some treatments do not consider zero a natural counting number
and use \(\mathbb{N}_0\) to symbolize the natural numbers <i>including</i>
zero.
</span>. Again,
what consequence does that have on doing arithmetic on \(\mathbb{N}\;\)?
For one, how would we do subtraction? Won&rsquo;t that crash if we try to
take a bigger number from a smaller number<label id='fnr.65' for='fnr-in.65.3390786' class='margin-toggle sidenote-number'><sup class='numeral'>65</sup></label><input type='checkbox' id='fnr-in.65.3390786' class='margin-toggle'><span class='sidenote'><sup class='numeral'>65</sup>
Supposedly, the idea of negative numbers came from the banking
world of the medieval age. So if I give you something that costs three
ducats and you only have two, then you <b>owe</b> me one ducat.
</span>? Subtraction is a
<i>binary operation</i><label id='fnr.66' for='fnr-in.66.8329943' class='margin-toggle sidenote-number'><sup class='numeral'>66</sup></label><input type='checkbox' id='fnr-in.66.8329943' class='margin-toggle'><span class='sidenote'><sup class='numeral'>66</sup>
We&rsquo;ll have more to say about binary operations when we look
into functions.
</span> of taking one amount from another. Asking in
higher-math-speak, <font color = "#4715b3">does the
binary operation of subtractions on all possible pairs of \(\mathbb{N}\)
yield results that <i>stay inside of</i> \(\mathbb{N}\;\)?</font>
</p>


\begin{align*}
\{(b -a) \in\,\mathbb{N}\; |\; a \in \mathbb{N},\: b \in \mathbb{N}\}
\end{align*}

<p>
or generally, where \(\circ\) means any sort of operator, e.g., \(+\),
\(-\), \(\div\), etc.
</p>

\begin{align*}
\{    \}
\end{align*}



<p>
Apparently not.
</p>

<p>
In more formal language, <font color = "#4715b3">the binary
operation of subtraction <i>on</i> (the members of) some set \(S\) will
assign to each and every possible pair \(a, b \in S\;\) a unique element
\(c \in S\) where \(c = a - b\). </font> That is, a binary
operation combines any two elements of the set to produce a third
element of that same set.
</p>

<p>
If you study this wording closely, it is definitely saying there can
be no such binary operator subtraction on \(\mathbb{N}\) because \(c\) can
definitely fall outside of \(\mathbb{N}\) &#x2014;as it does when, e.g., \(a =
6\) and \(b = 10\;\).<label id='fnr.67' for='fnr-in.67.127195' class='margin-toggle sidenote-number'><sup class='numeral'>67</sup></label><input type='checkbox' id='fnr-in.67.127195' class='margin-toggle'><span class='sidenote'><sup class='numeral'>67</sup>
Peruse <a href="https://math.libretexts.org/Bookshelves/Abstract_and_Geometric_Algebra/First-Semester_Abstract_Algebra%3A_A_Structural_Approach_(Sklar)/02%3A_Groups/2.01%3A_Binary_Operations_and_Structures">this</a> treatment of binary operations. Again, we&rsquo;ll dive
in deeper later.
</span> In math-speak, a binary operation \(a
\circ b\;\) must be <i>well-defined</i> and <i>inside of</i> \(S\)
</p>

<p>
\(\mathfrak{Fazit}\:\): The binary operation of subtraction is <i>not</i>
<b>closed</b> on \(\mathbb{N}\;\).
</p>


<p>
(Proof of addition on \(\mathbb{N}\;\)?)
</p>

<p>
Semigroups
</p>
</div>
</div>
<div id="outline-container-org3d7406a" class="outline-3">
<h3 id="org3d7406a">Unary numeral system</h3>
<div class="outline-text-3" id="text-org3d7406a">
<p>
There is the <i><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">unary numeral system</a></i> (UNS) where numbers are
represented in a <i>unary</i><label id='fnr.68' for='fnr-in.68.5516315' class='margin-toggle sidenote-number'><sup class='numeral'>68</sup></label><input type='checkbox' id='fnr-in.68.5516315' class='margin-toggle'><span class='sidenote'><sup class='numeral'>68</sup>
Unfortunately, <i>unary</i> here has two meanings. It means we&rsquo;re
only using one numeral to do our counting, <i>and</i> it indicates a unary
function, i.e., a function that takes only one value and returns only
something from its domain&#x2014;which is a very abstract version of the
idea of a <i>unary operator</i> where only one thing is operated on. For
example, addition is a <i>binary operation</i> since it takes <i>two</i> numbers
and adds them. But making a number a negative number by placing the
negative sign in front of the number is an example of a unary
operation.
</span> way, e.g., one is \(1\), two is \(11\),
three is \(111\), et cetera. The UNS system is not really positional,
i.e., the column of a \(1\) is immaterial since the \(1\)&rsquo;s are completely
interchangeable&#x2014;although when we want to go up a number, we do have
to move everything over one column. But again, the columns do not
indicate anything numerically as columns do with, e.g., our decimal
system<label id='fnr.69' for='fnr-in.69.5594510' class='margin-toggle sidenote-number'><sup class='numeral'>69</sup></label><input type='checkbox' id='fnr-in.69.5594510' class='margin-toggle'><span class='sidenote'><sup class='numeral'>69</sup>
More on the <i>binary</i> number system later.
</span>.
</p>

<p>
How would we add or subtract in our UNS system? Ironically, we could
invent a sort of columnar subtracting borrowing from decimal vertical
subtraction
</p>

\begin{array}{r}
&11111\\
-\!\!\!\!\!\!&11\\
\hline
&11100
\end{array}

<p>
then we just throw out the zeroes and count up the ones. But we can&rsquo;t
really do addition vertically. Perhaps not vertically but
horizontally
</p>

\begin{align*}
11111 + 11 = 1111111
\end{align*}

<p>
We could also remove the \(+\) and run together or <i>concatenate</i> the
\(1\)&rsquo;s. More on concatenation later.
</p>

<p>
Next, we write some Haskell code to do UNS subtraction<label id='fnr.70' for='fnr-in.70.7127346' class='margin-toggle sidenote-number'><sup class='numeral'>70</sup></label><input type='checkbox' id='fnr-in.70.7127346' class='margin-toggle'><span class='sidenote'><sup class='numeral'>70</sup>
Make sure you&rsquo;ve got past Chapter 6, <i>Higher Order Functions</i>
in LYAHFGG.
</span>
</p>
</div>
<div id="outline-container-org581a722" class="outline-5">
<h5 id="org581a722">UNS Subtraction</h5>
<div class="outline-text-5" id="text-org581a722">
<ul class="org-ul">
<li><a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101">LYAHFGG Typeclasses 101</a></li>
</ul>

<p>
Turning math into code means we must first decide which data structure
to use. For our string of \(1\)&rsquo;s we will use the Haskell <i>list</i> data
structure. This may seem ironic to a budding mathematician who
went down the set theory rabbit holes above. Yes, so much of math can
be seen as <i>set theory</i>-based. And no, a list is not a set. And yes,
Haskell has a library for sets. But as beginners we will simulate sets
with lists<label id='fnr.71' for='fnr-in.71.8057445' class='margin-toggle sidenote-number'><sup class='numeral'>71</sup></label><input type='checkbox' id='fnr-in.71.8057445' class='margin-toggle'><span class='sidenote'><sup class='numeral'>71</sup>
We could also represent our \(1\)&rsquo;s as a string, i.e., like text
between double-quotes, but any string in Haskell is just a list of the
text&rsquo;s individual characters, e.g., <code>"1111"</code> is really just
<code>['1','1','1','1']</code>.
</span>. This means our set of \(1\)&rsquo;s will be represented as
a list with the integer \(1\) repeated as its elements, e.g.,
<code>[1,1,1,1,1]</code> is \(11111\).
</p>

<p>
First we&rsquo;ll try a really primitive way to do UNS subtraction
</p>

<ul class="org-ul">
<li>Put \(1\)&rsquo;s into lists,</li>
<li>Apply the built-in list element counter function, <a href="http://zvon.org/other/haskell/Outputprelude/length_f.html">length</a>, on each to
count the number of \(1\)&rsquo;s in each,</li>
<li>Subtract one from the other.</li>
</ul>

<p>
Not very enlightening, but it works
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd31bf4f"><span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length <span class="org-rainbow-delimiters-depth-2">[</span>1,1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
2
</pre>


<p>
We can write our own function <code>uns1</code> for this taking two values as
input
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org0313799"><span class="org-haskell-definition">uns1</span> list1 list2 <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">-</span> <span class="org-rainbow-delimiters-depth-1">(</span>length list2<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb5d4a0e"><span class="org-haskell-definition">uns1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
2
</pre>


<p>
Now, let&rsquo;s create a better function utilizing Haskell&rsquo;s type and
recursion features<label id='fnr.72' for='fnr-in.72.5642681' class='margin-toggle sidenote-number'><sup class='numeral'>72</sup></label><input type='checkbox' id='fnr-in.72.5642681' class='margin-toggle'><span class='sidenote'><sup class='numeral'>72</sup>
We import <code>Data.List</code> to get, e.g., <code>null</code>. See <a href="https://wiki.haskell.org/Import">here</a> to
understand the syntax of nicknaming a package.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb671d45"><span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.List</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">L</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell" id="orgb04f825"><span class="org-haskell-definition">unsSub2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub2</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub2 l1x l2x
</pre>
</div>

<p>
We&rsquo;re relying on Haskell&rsquo;s pattern matching and guards to accomplish
loop-like behavior &#x2026; a lot at once. 
</p>

<p>
It seems to work when the subtrahend is smaller than the minuend
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org2c8b4f1"><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[1]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="orgebfd51c"><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[]
</pre>


<p>
But the following test exposes a problem, i.e., <code>unsSub2</code> gets things
backwards when the subtrahend is larger than the minuend. This is a
<i>logic error</i>, i.e., the code evaluates and runs, but produces bad
output
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org0970ed4"><span class="org-haskell-definition">unsSub2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[1,1]
</pre>


<p>
We can correct this by changing the second line <code>3</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="linenr">1: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="linenr">2: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="linenr">3: </span><span class="org-haskell-definition">unsSub21</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="linenr">4: </span>                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="linenr">5: </span><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub21 l1x l2x
<span class="linenr">6: </span><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Now it works
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgd43fc94"><span class="org-haskell-definition">unsSub21</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:369:1-8: error:
    Variable not in scope: unsSub21 :: [a0] -&gt; [a1] -&gt; t
    Suggested fix:
      Perhaps use one of these: ‘unsSub2’ (line 12), ‘unsSub3’ (line 17)
</pre>


<p>
Another attempt would have us turn any extra \(1\)&rsquo;s in the minuend
turned into \(-1\)&rsquo;s. No, it&rsquo;s not exactly UNS, but we&rsquo;re just
practicing here. <code>unsSub3</code> below should do it, but the first
evaluation gives an error<label id='fnr.73' for='fnr-in.73.2986018' class='margin-toggle sidenote-number'><sup class='numeral'>73</sup></label><input type='checkbox' id='fnr-in.73.2986018' class='margin-toggle'><span class='sidenote'><sup class='numeral'>73</sup>
Eventually you&rsquo;ll be a pro with Haskell error messages, but
for now we&rsquo;ll just have to puzzle them out.
</span>: There is something wrong with the
type declaration.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-1">[</span>a<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>L.map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</pre>
</div>

<pre class="example" id="org8d4c2f8">
No instance for (Num a) arising from a use of ‘negate’
  ...
</pre>

<p>
One trick is to simply comment out your type declaration and try again
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org9fb1fbd"><span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub3 :: [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span>L.map negate l2x<span class="org-rainbow-delimiters-depth-1">)</span>
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
</pre>
</div>

<p>
When we allow Haskell to infer the type, we have success.
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org30a4d89"><span class="org-haskell-constructor">:</span>t unsSub3
</pre>
</div>

<pre class="example">
unsSub3 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>


<p>
Because we&rsquo;re using <code>negate</code> our list type <code>[a]</code> cannot be just
anything, rather, the <code>a</code>&rsquo;s, the list elements, must be instances
of the class <code>Num</code>. Retrying with Haskell&rsquo;s type declaration
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub3</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Num</span> a <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub3</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>L.map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
this evaluates. Now
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsSub3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[-1,-1,-1]
</pre>


<p>
One improvement would be to make sure our input lists are made up of
just ones. For this we have a choice of Haskell built-ins like
<code>filter</code>, <code>all</code>, <code>map</code>, <code>any</code>, and <code>elem</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org5b806d2"><span class="org-haskell-definition">list1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
<span class="org-haskell-definition">list2</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
One version using <code>any</code> to test for not equal to <code>1</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> list2
</pre>
</div>

<pre class="example">
True
</pre>


<p>
Another version of testing for not equal to <code>1</code> using a (lambda)
anonymous function
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">any</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> list2  <span class="org-comment-delimiter">-- </span><span class="org-comment">checks if any in the list conform to test</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
We can test <i>two</i> lists by using <code>Boolean</code> <i>or</i> <code>(||)</code> 
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-1">(</span>any <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> list2<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
<code>filter</code> returns a list with elements conforming to the test
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">filter</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[]
</pre>


<p>
<code>all</code> checks if all elements conform to test and returns <code>Boolean</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-1">)</span>  <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,2<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
False
</pre>


<p>
<code>map</code>, (see <a href="http://learnyouahaskell.com/higher-order-functions#maps-and-filters">Maps and filters</a>) which we&rsquo;ll use extensively, applies the
test to a list and outputs a new list with the outcomes of each test
on each input list element. Here the test is an anonymous function
testing again for not equal to <code>1</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">L<span class="org-haskell-definition">.</span>map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&gt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>x <span class="org-haskell-operator">&lt;</span> 1<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,1,2,3,4<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[True,False,True,True,True]
</pre>


<p>
<code>elem</code> with type <code>Eq a =&gt; a -&gt; [a] -&gt; Bool</code> is not quite as handy
since it doesn&rsquo;t allow for a <code>Boolean</code> predicate test. So yes, we
could test if <code>1</code> is an element of a list, but not if <i>all</i> are
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">elem</span> 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">||</span> elem 1 <span class="org-rainbow-delimiters-depth-1">[</span>1,2,3<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
We can &ldquo;trick&rdquo; <code>elem</code> into helping us. First, we produce a list
created from <code>map</code> as above testing each element for <code>1</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">L<span class="org-haskell-definition">.</span>map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[False,False,True,False]
</pre>


<p>
Then <code>elem</code> will tell us if any elements were not equal to <code>1</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">elem</span> <span class="org-haskell-constructor">True</span> <span class="org-haskell-operator">$</span> L.map <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
We&rsquo;ll build in a test using <code>any</code>, but like before, this code doesn&rsquo;t
evaluate properly
</p>

<pre class="example" id="orgb2aae9d">
unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]
unsSub4 l1x l2x | (any (\x -&gt; x /= 1) l1x) || (any (\y -&gt; y /= 1) l2x) = []
unsSub4 l1x l2x | L.null l1x = (L.map negate l2x)
                | L.null l2x = l1x
unsSub4 (l1:l1x) (l2:l2x) = unsSub4 l1x l2x
</pre>

<p>
The error once again complains of something to do with the elements
<code>a</code> of the input arrays
</p>

<pre class="example" id="org533c50e">
Could not deduce (Eq a) arising from a use of ‘/=’
...
Possible fix:
        add (Eq a) to the context of
          the type signature for:
            unsSub4 :: forall a. Num a =&gt; [a] -&gt; [a] -&gt; [a]
</pre>

<p>
Again, we&rsquo;ll leave out a type declaration and see what Haskell thinks
it is
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">unsSub4 :: Num a =&gt; [a] -&gt; [a] -&gt; [a]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>L.map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>t unsSub4
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-7: error:
    Variable not in scope: unsSub4
    Suggested fix:
      Perhaps use one of these: ‘unsSub2’ (line 12), ‘unsSub3’ (line 17)
</pre>


<p>
Trying this
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsSub4</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsSub4</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-2">(</span>L.map negate l2x<span class="org-rainbow-delimiters-depth-2">)</span>
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> unsSub4 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
and it evaluates. What&rsquo;s happening? As before, the input element <code>a</code>&rsquo;s
type must also be an instance of the <code>Eq</code> class, which means there has
to be a way to <i>equate</i> any pair of <code>a</code>&rsquo;s
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</pre>
</div>

<pre class="example" id="org25cc984">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance (Eq a, Eq b) =&gt; Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a =&gt; Eq [a] -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Word -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Ordering -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
instance Eq Int -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
</pre>

<p>
What <code>:i</code> or <code>:info</code> is saying about the typeclass <code>Eq</code> is that in
order to be an instance of it, input <code>a</code> must have defined what
happens when two of its members are subjected to an equality tests
<code>(==)</code> and <code>(/=)</code>.
</p>

<p>
Now <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code> restricts <code>a</code> to
being a value that has instances for <code>Eq</code> <i>and</i> <code>Num</code> registered. Why
is this important? Because without specifying, <i>anticipating</i> the
ability to perform equality (<code>Eq</code>) comparisons on only numerical
values (<code>Num</code>), other non-numerical values for <code>a</code> might give false
output. When we declare the function <code>unsSub4</code>&rsquo;s input and output
types with <code>unsSub4 :: (Eq a, Num a) =&gt; [a] -&gt; [a] -&gt; [a]</code>, we are
guaranteeing sane behavior.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,2<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:397:1-7: error:
    Variable not in scope: unsSub4 :: [a0] -&gt; [a1] -&gt; t
    Suggested fix:
      Perhaps use one of these: ‘unsSub2’ (line 12), ‘unsSub3’ (line 17)
</pre>


<p>
What will happen if we use lists of strings of <code>1</code>?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsSub4</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span>,<span class="org-string">"1"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:399:1-7: error:
    Variable not in scope: unsSub4 :: [String] -&gt; [String] -&gt; t
    Suggested fix:
      Perhaps use one of these: ‘unsSub2’ (line 12), ‘unsSub3’ (line 17)
</pre>


<p>
Again, Haskell is playing it safe. We haven&rsquo;t made Haskell aware of
any way to handle strings as list elements. We use <code>(/=)</code>, which will work
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-string">'1'</span> <span class="org-haskell-operator">/=</span> <span class="org-string">'2'</span>
</pre>
</div>

<pre class="example">
True
</pre>


<p>
but we haven&rsquo;t accounted for <code>negate</code> which wants to negate an actual
number. Looking into <code>negate</code>&rsquo;s type
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>t negate
</pre>
</div>

<pre class="example">
negate :: Num a =&gt; a -&gt; a
</pre>


<p>
we see it cannot handle anything but numbers registered with the
typeclass <code>Num</code>. So yes, we can use string versions of <code>1</code>, but that&rsquo;s
because there is a registered instance for <code>Char</code> which defines behind
the scenes how to equate numbers
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>i <span class="org-haskell-constructor">Eq</span>
</pre>
</div>

<pre class="example" id="org0b91ca2">
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
instance Eq Char -- Defined in ‘ghc-prim-0.6.1:GHC.Classes’
...
</pre>
</div>
</div>
<div id="outline-container-org353ca53" class="outline-5">
<h5 id="org353ca53">UNS Addition</h5>
<div class="outline-text-5" id="text-org353ca53">
<ul class="org-ul">
<li><a href="http://learnyouahaskell.com/recursion#hello-recursion">LYAHFFG Hello Recursion!</a></li>
</ul>

<p>
As you saw in LYAHFGG, recursion is the Haskell way of looping. UNS
addition, as represented by lists, will be a simple matter of
combining two lists of <code>1</code>&rsquo;s into one total list. Borrowing from
above, we can start out very simple by concatenating the lists
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-haskell-operator">++</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[1,1,1,1,1,1]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="orgdcdebe5"><span class="org-haskell-definition">uns2</span> list1 list2 <span class="org-haskell-operator">=</span> list1 <span class="org-haskell-operator">++</span> list2
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd1</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>x <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span>any <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">\</span>y <span class="org-haskell-operator">-&gt;</span> y <span class="org-haskell-operator">/=</span> 1<span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd1</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd1 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsAdd1</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:409:1-7: error:
    Variable not in scope: unsAdd1 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
<code>unsAdd1</code> gives a nice example of recursion. But what if any of the
list elements are negative <code>1</code>&rsquo;s? Let&rsquo;s say if the lists contain
<code>-1</code>&rsquo;s we&rsquo;ll take away a positive <code>1</code>. One approach would be to just
concatenate both lists, then go through removing positive and negative
pairs
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd2</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-type">Eq</span> a, <span class="org-haskell-type">Num</span> a<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-haskell-operator">-&gt;</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l1x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
                  <span class="org-haskell-operator">||</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span>1<span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-haskell-operator">&amp;&amp;</span> <span class="org-rainbow-delimiters-depth-3">(</span>any <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-haskell-operator">/=</span><span class="org-rainbow-delimiters-depth-5">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> l2x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd2</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd2 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsAdd2</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:411:1-7: error:
    Variable not in scope: unsAdd2 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
Here&rsquo;s a variant where the test for <code>1</code> and <code>-1</code> is somewhat shorter
building on this idea
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">all</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-2">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
True
</pre>



<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">&amp;&amp;</span> not <span class="org-rainbow-delimiters-depth-2">(</span>all <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">`elem`</span> <span class="org-rainbow-delimiters-depth-4">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">)</span> l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">[]</span></span>
<span class="org-haskell-definition">unsAdd3</span> l1x l2x <span class="org-haskell-operator">|</span> L.null l1x <span class="org-haskell-operator">=</span> l2x
                <span class="org-haskell-operator">|</span> L.null l2x <span class="org-haskell-operator">=</span> l1x
<span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-2">(</span>l1<span class="org-haskell-constructor">:</span>l1x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">(</span>l2<span class="org-haskell-constructor">:</span>l2x<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">=</span> l1 <span class="org-haskell-constructor">:</span> l2 <span class="org-haskell-constructor">:</span> unsAdd3 l1x l2x
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsAdd3</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:415:1-7: error:
    Variable not in scope: unsAdd3 :: [a0] -&gt; [a1] -&gt; t
</pre>


<p>
One simple idea would be to use a <i>fold</i>, e.g.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
3
</pre>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">foldr</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-1">)</span> 0 <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
-1
</pre>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd4</span> l1x l2x <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> ux <span class="org-haskell-operator">=</span> l1x <span class="org-haskell-operator">++</span> l2x
                  <span class="org-haskell-keyword">in</span> collps ux
                     <span class="org-haskell-keyword">where</span> collps <span class="org-haskell-operator">=</span> foldr <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">\</span>x acc <span class="org-haskell-operator">-&gt;</span> x <span class="org-haskell-operator">+</span> acc<span class="org-rainbow-delimiters-depth-2">)</span> 0
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsAdd4</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,1,1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:421:1-7: error:
    Variable not in scope: unsAdd4 :: [a0] -&gt; [a1] -&gt; t
</pre>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">unsAdd5</span> ux <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">let</span> pux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span>1<span class="org-rainbow-delimiters-depth-2">)</span> ux
                 mux <span class="org-haskell-operator">=</span> filter <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-haskell-operator">==</span><span class="org-rainbow-delimiters-depth-3">(</span><span class="org-haskell-operator">-</span>1<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> ux
             <span class="org-haskell-keyword">in</span> pux <span class="org-haskell-operator">++</span> mux
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">unsAdd5</span> <span class="org-rainbow-delimiters-depth-1">[</span>1,<span class="org-haskell-operator">-</span>1,1,1,<span class="org-haskell-operator">-</span>1,<span class="org-haskell-operator">-</span>1,1,<span class="org-haskell-operator">-</span>1,1,1,1,1<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:423:1-7: error:
    Variable not in scope: unsAdd5 :: [a0] -&gt; t
</pre>
</div>
</div>
<div id="outline-container-org72ffebb" class="outline-4">
<h4 id="org72ffebb">In closing: Some UNS Theory</h4>
<div class="outline-text-4" id="text-org72ffebb">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Unary_numeral_system">Unary numeral system</a></li>
<li><a href="https://math.stackexchange.com/questions/4444174/why-is-a-unary-numeral-system-bijective">Why is a unary numeral system bijective?</a></li>
</ul>

<p>
The UNS is considered a <i>bijective base-1 numeral system</i>. How is
<i>bijective</i> meant here? The answer is to imagine the set of all whole
numerals \(1,2,\ldots,\infin\;\), and then the set of all UNS 1-strings,
e.g., <code>1</code>, <code>11</code>, <code>111</code>. These two sets are mapped bijectively, as with
bijective functions. The term <i>unary</i> can be interpreted mainly as a
number system having only one digit. However, when we explore Peano
numbers, we will revisit the idea of unary functions and unary
operators.
</p>
</div>
</div>
</div>
<div id="outline-container-org4a5aef7" class="outline-3">
<h3 id="org4a5aef7">Binary number system</h3>
<div class="outline-text-3" id="text-org4a5aef7">
<ul class="org-ul">
<li>chamberlandsingle</li>
</ul>

<p>
The unary system
</p>
</div>
</div>
<div id="outline-container-org06d80e1" class="outline-3">
<h3 id="org06d80e1">Real numbers are based upon&#x2026;</h3>
<div class="outline-text-3" id="text-org06d80e1">
<ul class="org-ul">
<li>goldrei1998classic</li>
</ul>


<p>
Or we could say &ldquo;the number after
four.&rdquo; But that&rsquo;s just the number after three&#x2014;and so on until we
arrive at zero, which we call, yes, zero, and write as \(0\). So in this
system, \(5\) would be&#x2026;
</p>

<p>
<p style="padding-left: 30px">
<font color = "#4715b3">
&#x2026;the next, next, next, next, next number after zero.
</font>
</p>
</p>

<p>
But just to check this for accuracy, we again fall back on numerical
symbols and names. So we count the number of <i>next</i>&rsquo;s and translate
this chain of next links back into \(5\).
</p>

<p>
So we seem to be stuck with names and symbols, our <i>numbering system</i>,
so to speak, to even get off the ground with numbers as representative
of amounts. However, mathematics will want to take us much further
into the conceptualization of numbers, abstractions far beyond the
simple notion of how many. In abstract algebra, operations on numbers
such as addition and subtraction have consequences beyond number names
or symbols. So the subtraction of one natural number from another is a
&ldquo;taking away&rdquo; of one amount from another. But what if we try to take
\(3\) from \(2\;\)? To take \(3\) from \(2\) would land us outside the
counting whole numbers \(\mathbb{N}\;\), would it not?  After all, \(2 -
3\) is \(-1\), i.e., we went past \(0\) and landed one tick below in
&ldquo;negative territory.&rdquo; The <i>integers</i> (denoted by \(\mathbb{Z}\))
abstracts \(\mathbb{N}\;\) by symmetrically mirroring, duplicating all
its positive whole numbers into their negative counterparts. However,
the operation of addition in \(\mathbb{N}\) would not ever take us into
negatives. Any two (sic) natural numbers we might add together would
produce another member of the natural numbers somewhere further up the
list of \(\mathbb{N}\;\). But now we&rsquo;re concerned with where in the
list. Hence, <i>order</i> is our next abstraction beyond just naming
amounts. And as you might suspect, the most basic ordering of numbers
is to &ldquo;line them up&rdquo; according to their amounts<label id='fnr.74' for='fnr-in.74.7170289' class='margin-toggle sidenote-number'><sup class='numeral'>74</sup></label><input type='checkbox' id='fnr-in.74.7170289' class='margin-toggle'><span class='sidenote'><sup class='numeral'>74</sup>
How would you order a box of crayons? One way would be
by their colors. But is brown ahead or behind green? Crayon colors
don&rsquo;t seem to have an ahead or behind, maybe just a &ldquo;beside&rdquo; or &ldquo;along
with&rdquo; perhaps?
</span>.
</p>

<p>
When we played with the notion of <i>next</i> above, it was as if we
started by feeding a basic starting thing, a <i>zero</i>, into a <i>next
machine</i>, and out came &ldquo;the next thing after zero&rdquo;. We might have
noted that to be \(1\). Then if we feed our zero adorned with next into
the next machine again we get &ldquo;the <i>next</i>, next thing after zero&rdquo; And
we write that down somewhere as \(2\). In effect, we&rsquo;re constructing a
way to string ticks together into a chain, forging a new chain link
for each new tick. Then instead of having a name or symbol, we could
just show the whole chain. Odd and awkward?  But this is exactly what
the Italian mathematician Giuseppe Peano (following up on work done by
the German mathematician Richard Dedekind) formulated in order to put
the notion of natural numbers on a more mathematically-sound footing.
</p>
</div>
</div>
</section>
<section id="outline-container-orga42f1d3" class="outline-2">
<h2 id="orga42f1d3">Sets</h2>
<div class="outline-text-2" id="text-orga42f1d3">
</div>
<div id="outline-container-org85cee69" class="outline-3">
<h3 id="org85cee69">Set beginnings</h3>
<div class="outline-text-3" id="text-org85cee69">
<ul class="org-ul">
<li>van2010computational</li>
</ul>

<p>
To check whether two sets are the same one has to check that they have
the same members. The fact that membership is all there is to set
identity, or that sets are fully determined by their members, is
called the <i>principle of extensionality</i>.
</p>

<p>
<i>Set comprehensions</i> are math shorthand for declaring sets
</p>

<p>
𝖟𝕭: The set of all natural numbers multiplied by \(2\)
</p>

\begin{align*}
E = \{2n \; | \; n \in \mathbb{N}\}
\end{align*}

<p>
We could now have a variation such as
</p>

\begin{align*}
O = \{n \;|\; n \in \mathbb{N}, n \notin E\}
\end{align*}


<p>
If every member of a set \(A\) is also a member of set \(B\) we say that
\(A\) is a subset of \(B\), written as \(A \subseteq B\). If \(A \subseteq B\)
and \(B \subseteq A\) then it follows by the <i>principle of
extensionality</i> that \(A\) and \(B\) are the same set. Conversely, if \(A
= B\;\) then it follows that \(A \subseteq B\) and \(B \subseteq A\).
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="org00e6e4b"><span class="org-haskell-keyword">import</span> <span class="org-haskell-keyword">qualified</span> <span class="org-haskell-constructor">Data.Set</span> <span class="org-haskell-keyword">as</span> <span class="org-haskell-constructor">S</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">let</span> s1 <span class="org-haskell-operator">=</span> Set.fromList <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">"a"</span>, <span class="org-string">"b"</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:425:10-21: error:
    Not in scope: ‘Set.fromList’
    NB: no module named ‘Set’ is imported.
    Suggested fix: Perhaps use ‘S.fromList’ (imported from Data.Set)
</pre>


<div class="org-src-container">
<pre class="src src-haskell">s1
</pre>
</div>

<p>
What about a descriptive definition such as
</p>

\begin{align*}
\text{For allx } x \in P\text{, there existsy } y > x \text{ such that } y \in P.
\end{align*}



<p>
➝
<font color = "#4715b3">
For all \(x \in P\), there exists \(y > x\) such that \(y \in P\).
</font> <br>
</p>


<div class="org-src-container">
<pre class="src src-haskell" id="orga7d7645"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">(</span>x,y,z<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span>, z <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-haskell-constructor">True</span>,<span class="org-haskell-constructor">False</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[(True,True,True),(True,True,False),(True,False,True),(True,False,False),(False,True,True),(False,True,False),(False,False,True),(False,False,False)]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org430a3f8"><span class="org-rainbow-delimiters-depth-1">[</span>y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[False,True,True,True,True,True,True,True,True,True,True,True,True,True,True,False,False,True,True,True,True,True,True,True,True,True,True,True,True,True,False,False,False,True,True,True,True,True,True,True,True,True,True,True,True,False,False,False,False,True,True,True,True,True,True,True,True,True,True,True,False,False,False,False,False,True,True,True,True,True,True,True,True,True,True,False,False,False,False,False,False,True,True,True,True,True,True,True,True,True,False,False,False,False,False,False,False,True,True,True,True,True,True,True,True,False,False,False,False,False,False,False,False,True,True,True,True,True,True,True,False,False,False,False,False,False,False,False,False,True,True,True,True,True,True,False,False,False,False,False,False,False,False,False,False,True,True,True,True,True]
</pre>



<div class="org-src-container">
<pre class="src src-haskell"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-haskell-keyword">if</span> y <span class="org-haskell-operator">&gt;</span> x <span class="org-haskell-keyword">then</span> y <span class="org-haskell-keyword">else</span> 0  <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>15<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,0,3,4,5,6,7,8,9,10,11,12,13,14,15,0,0,0,4,5,6,7,8,9,10,11,12,13,14,15,0,0,0,0,5,6,7,8,9,10,11,12,13,14,15,0,0,0,0,0,6,7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,7,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,8,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,9,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,11,12,13,14,15]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org8e43c0d"><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, y <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>5<span class="org-haskell-operator">..</span>20<span class="org-rainbow-delimiters-depth-2">]</span>, x <span class="org-haskell-operator">&lt;</span> y <span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org642acbc"><span class="org-haskell-definition">filter</span> even <span class="org-rainbow-delimiters-depth-1">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[2,4,6,8,10]
</pre>


<div class="org-src-container">
<pre class="src src-haskell" id="org44eb2f1"><span class="org-rainbow-delimiters-depth-1">[</span>x <span class="org-haskell-operator">|</span> x <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-haskell-operator">..</span>10<span class="org-rainbow-delimiters-depth-2">]</span>, <span class="org-rainbow-delimiters-depth-2">(</span>even x<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<pre class="example">
[2,4,6,8,10]
</pre>





<table id="org3ad54cf">


<colgroup>
<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">12</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">24</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">48</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">96</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">192</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">384</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">768</td>
</tr>
</tbody>
</table>


<figure id="org7735d91">
<img src="./images/expo3.svg" alt="expo3.svg" class="org-svg">

</figure>

<table id="org2398fee">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<table id="orgaa67ed1">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">-2</td>
<td class="org-right">-1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
<td class="org-right">6</td>
<td class="org-right">7</td>
</tr>

<tr>
<td class="org-right">0.25</td>
<td class="org-right">0.5</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">16</td>
<td class="org-right">32</td>
<td class="org-right">64</td>
<td class="org-right">128</td>
</tr>
</tbody>
</table>

<p>
If some process is increasing at an exponential rate, it
means that for each unit of change the rate is growing or decreasing
by a <i>common ratio</i>. In the example above, the common ratio is \(2\).
</p>

<table id="org95a22c0">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">independent var</th>
<th scope="col" class="org-right">first dependent var</th>
<th scope="col" class="org-right">second dependent var</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0.1</td>
<td class="org-right">0.425</td>
<td class="org-right">0.375</td>
</tr>

<tr>
<td class="org-right">0.2</td>
<td class="org-right">0.3125</td>
<td class="org-right">0.3375</td>
</tr>

<tr>
<td class="org-right">0.3</td>
<td class="org-right">0.24999993</td>
<td class="org-right">0.28333338</td>
</tr>

<tr>
<td class="org-right">0.4</td>
<td class="org-right">0.275</td>
<td class="org-right">0.28125</td>
</tr>

<tr>
<td class="org-right">0.5</td>
<td class="org-right">0.26</td>
<td class="org-right">0.27</td>
</tr>

<tr>
<td class="org-right">0.6</td>
<td class="org-right">0.25833338</td>
<td class="org-right">0.24999993</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">0.24642845</td>
<td class="org-right">0.23928553</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">0.23125</td>
<td class="org-right">0.2375</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">0.23333323</td>
<td class="org-right">0.2333332</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0.2225</td>
<td class="org-right">0.22</td>
</tr>

<tr>
<td class="org-right">1.1</td>
<td class="org-right">0.20909075</td>
<td class="org-right">0.22272708</td>
</tr>

<tr>
<td class="org-right">1.2</td>
<td class="org-right">0.19999998</td>
<td class="org-right">0.21458333</td>
</tr>

<tr>
<td class="org-right">1.3</td>
<td class="org-right">0.19615368</td>
<td class="org-right">0.21730748</td>
</tr>

<tr>
<td class="org-right">1.4</td>
<td class="org-right">0.18571433</td>
<td class="org-right">0.21071435</td>
</tr>

<tr>
<td class="org-right">1.5</td>
<td class="org-right">0.19000008</td>
<td class="org-right">0.2150001</td>
</tr>

<tr>
<td class="org-right">1.6</td>
<td class="org-right">0.1828125</td>
<td class="org-right">0.2046875</td>
</tr>

<tr>
<td class="org-right">1.7</td>
<td class="org-right">0.18088253</td>
<td class="org-right">0.1985296</td>
</tr>

<tr>
<td class="org-right">1.8</td>
<td class="org-right">0.17916675</td>
<td class="org-right">0.18888898</td>
</tr>

<tr>
<td class="org-right">1.9</td>
<td class="org-right">0.19342103</td>
<td class="org-right">0.21315783</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0.19</td>
<td class="org-right">0.21625</td>
</tr>

<tr>
<td class="org-right">2.1</td>
<td class="org-right">0.18214268</td>
<td class="org-right">0.20714265</td>
</tr>

<tr>
<td class="org-right">2.2</td>
<td class="org-right">0.17727275</td>
<td class="org-right">0.2022727</td>
</tr>

<tr>
<td class="org-right">2.3</td>
<td class="org-right">0.1739131</td>
<td class="org-right">0.1989131</td>
</tr>

<tr>
<td class="org-right">2.4</td>
<td class="org-right">0.16770833</td>
<td class="org-right">0.1916667</td>
</tr>

<tr>
<td class="org-right">2.5</td>
<td class="org-right">0.164</td>
<td class="org-right">0.188</td>
</tr>

<tr>
<td class="org-right">2.6</td>
<td class="org-right">0.15769238</td>
<td class="org-right">0.18076923</td>
</tr>

<tr>
<td class="org-right">2.7</td>
<td class="org-right">0.1592591</td>
<td class="org-right">0.1888887</td>
</tr>

<tr>
<td class="org-right">2.8</td>
<td class="org-right">0.1598214</td>
<td class="org-right">0.18928565</td>
</tr>

<tr>
<td class="org-right">2.9</td>
<td class="org-right">0.15603453</td>
<td class="org-right">0.1844828</td>
</tr>
</tbody>
</table>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgb68b394" class="outline-3">
<h3 id="orgb68b394">Rational numbers</h3>
<div class="outline-text-3" id="text-orgb68b394">
<p>
In Haskell rational numbers are handled by <code>Data.Ratio</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell" id="orgbe2e0c4"><span class="org-haskell-keyword">import</span> <span class="org-haskell-constructor">Data.Ratio</span>
</pre>
</div>

<p>
The basic &ldquo;give back the simplest form&rdquo; function is <code>%</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">50 <span class="org-haskell-operator">%</span> 10
</pre>
</div>

<pre class="example">
5 % 1
</pre>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">numerator</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
3
</pre>


<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-comment-delimiter">-- </span><span class="org-comment">combRatio :: Ratio</span>
<span class="org-haskell-definition">combRatio</span> r <span class="org-haskell-operator">=</span> show <span class="org-rainbow-delimiters-depth-2">(</span>numerator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-haskell-operator">++</span> <span class="org-string">"/"</span> <span class="org-haskell-operator">++</span> show <span class="org-rainbow-delimiters-depth-2">(</span>denominator <span class="org-rainbow-delimiters-depth-3">(</span>r<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">combRatio</span> <span class="org-rainbow-delimiters-depth-1">(</span>60 <span class="org-haskell-operator">%</span> 20<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:445:1-9: error:
    Variable not in scope: combRatio :: Ratio a0 -&gt; t
</pre>


<p>
⇲ Tip: Put an infix operator in parentheses to use as prefix
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">r1</span> <span class="org-haskell-operator">=</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-operator">%</span><span class="org-rainbow-delimiters-depth-1">)</span> 50 10
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span>t r1
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:1:1-2: error: Variable not in scope: r1
</pre>


<div class="org-src-container">
<pre class="src src-haskell">60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a
</pre>
</div>

<pre class="example">
3 % 1
</pre>


<div class="org-src-container">
<pre class="src src-haskell">60 <span class="org-haskell-operator">%</span> 20 <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Rational</span>
</pre>
</div>

<pre class="example">
3 % 1
</pre>


<p>
First, the data type
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> <span class="org-haskell-type">Ratio</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">!</span>a <span class="org-haskell-constructor">:%</span> <span class="org-haskell-operator">!</span>a  <span class="org-haskell-keyword">deriving</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">Eq</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
The <code>:%</code> is a data constructor (the <code>:</code> insures it&rsquo;s a <i>constructor</i>
and not just an operator function) that is placed between the two
<code>Integral</code> parameters. But in the source <code>%</code> calls <code>reduce</code><label id='fnr.75' for='fnr-in.75.7277119' class='margin-toggle sidenote-number'><sup class='numeral'>75</sup></label><input type='checkbox' id='fnr-in.75.7277119' class='margin-toggle'><span class='sidenote'><sup class='numeral'>75</sup>
<code>quot</code> returns the quotient, discards the remainder; <code>gcd</code> is
the built-in <i>greatest common divisor</i>; <code>signum</code> gives back <code>1</code> if
argument is greater than zero, <code>-1</code> if less than zero, zero if zero.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">reduce</span> <span class="org-haskell-operator">::</span>  <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
<span class="org-haskell-pragma">{-# SPECIALISE reduce :: Integer -&gt; Integer -&gt; Rational #-}</span>
<span class="org-haskell-definition">reduce</span> <span class="org-haskell-keyword">_</span> 0              <span class="org-haskell-operator">=</span>  ratioZeroDenominatorError
<span class="org-haskell-definition">reduce</span> x y              <span class="org-haskell-operator">=</span>  <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-constructor">:%</span> <span class="org-rainbow-delimiters-depth-1">(</span>y <span class="org-haskell-operator">`quot`</span> d<span class="org-rainbow-delimiters-depth-1">)</span>
                           <span class="org-haskell-keyword">where</span> d <span class="org-haskell-operator">=</span> gcd x y
<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-definition">%</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">::</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-type">Integral</span> a<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-haskell-operator">=&gt;</span> a <span class="org-haskell-operator">-&gt;</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Ratio</span> a
x <span class="org-haskell-definition">%</span> y <span class="org-haskell-operator">=</span>  reduce <span class="org-rainbow-delimiters-depth-1">(</span>x <span class="org-haskell-operator">*</span> signum y<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>abs y<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">quot</span> 6 3 <span class="org-comment-delimiter">-- </span><span class="org-comment">returns the quotient, discards the remainder, if any</span>
</pre>
</div>

<pre class="example">
2
</pre>
</div>
<div id="outline-container-org674ae05" class="outline-4">
<h4 id="org674ae05">GCD and the Euclidean algorithm</h4>
<div class="outline-text-4" id="text-org674ae05">
<ul class="org-ul">
<li><a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Wikipedia Euclidean algorithm</a></li>
</ul>

<p>
The built-in Haskell <code>gcd</code> was used to reduce the rational number,
e.g., fraction, to its lowest terms.
</p>

<p>
𝖟𝕭. Find the lowest terms of \(42/56\)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">gcd</span> 42 56
</pre>
</div>

<pre class="example">
14
</pre>


<p>
i.e., \(14\) is the greatest common divisor of both \(42\) and \(56\)
</p>

<p>
\[
\frac{42}{56}
\]
</p>


<p>
<i>Euclid&rsquo;s algorithm</i>, is an efficient method for computing the
greatest common divisor (GCD) of two integers (numbers), the largest
number that divides them both without a remainder.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">eGCD</span> <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Integral</span> i <span class="org-haskell-operator">=&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i <span class="org-haskell-operator">-&gt;</span> i
<span class="org-haskell-definition">eGCD</span> 0 b <span class="org-haskell-operator">=</span> b
<span class="org-haskell-definition">eGCD</span> a b <span class="org-haskell-operator">=</span> eGCD <span class="org-rainbow-delimiters-depth-2">(</span>b <span class="org-haskell-operator">`mod`</span> a<span class="org-rainbow-delimiters-depth-2">)</span> a
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">eGCD</span> 60 25
</pre>
</div>

<pre class="example">
&lt;interactive&gt;:457:1-4: error:
    Variable not in scope: eGCD :: t0 -&gt; t1 -&gt; t
</pre>
</div>
</div>
<div id="outline-container-org6d5213f" class="outline-4">
<h4 id="org6d5213f">Perfect numbers</h4>
<div class="outline-text-4" id="text-org6d5213f">
<p>
This code give the first four <i>perfect numbers</i><label id='fnr.76' for='fnr-in.76.5558105' class='margin-toggle sidenote-number'><sup class='numeral'>76</sup></label><input type='checkbox' id='fnr-in.76.5558105' class='margin-toggle'><span class='sidenote'><sup class='numeral'>76</sup>
In number theory, a <i>perfect number</i> is a positive integer that
is equal to the sum of its positive divisors, excluding the number
itself. For instance, \(6\) has divisors \(1\), \(2\) and \(3\) (excluding
itself), and \(1 + 2 + 3 = 6\;\), so \(6\) is a perfect number.
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-haskell-definition">main</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-keyword">do</span>
  <span class="org-haskell-keyword">let</span> n <span class="org-haskell-operator">=</span> 4
  mapM_ print <span class="org-haskell-operator">$</span>
    take n <span class="org-rainbow-delimiters-depth-2">[</span>candidate <span class="org-haskell-operator">|</span> candidate <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> 2 <span class="org-haskell-operator">^</span> 19<span class="org-rainbow-delimiters-depth-3">]</span>, getSum candidate <span class="org-haskell-operator">==</span> 1 <span class="org-rainbow-delimiters-depth-2">]</span>
    <span class="org-haskell-keyword">where</span>
      getSum candidate <span class="org-haskell-operator">=</span>
        1 <span class="org-haskell-operator">%</span> candidate <span class="org-haskell-operator">+</span> sum <span class="org-rainbow-delimiters-depth-2">[</span>1 <span class="org-haskell-operator">%</span> factor <span class="org-haskell-operator">+</span> 1 <span class="org-haskell-operator">%</span> <span class="org-rainbow-delimiters-depth-3">(</span>candidate <span class="org-haskell-operator">`div`</span> factor<span class="org-rainbow-delimiters-depth-3">)</span>
                            <span class="org-haskell-operator">|</span> factor <span class="org-haskell-operator">&lt;-</span> <span class="org-rainbow-delimiters-depth-3">[</span>2 <span class="org-haskell-operator">..</span> floor <span class="org-rainbow-delimiters-depth-4">(</span>sqrt <span class="org-rainbow-delimiters-depth-5">(</span>fromIntegral candidate<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
                            , candidate <span class="org-haskell-operator">`mod`</span> factor <span class="org-haskell-operator">==</span> 0 <span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-haskell-constructor">:</span><span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-haskell">main
</pre>
</div>

<pre class="example">
Suggested fix: Perhaps use ‘min’ (imported from Prelude)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgece717a" class="outline-3">
<h3 id="orgece717a">Power series</h3>
<div class="outline-text-3" id="text-orgece717a">
<p>
Something<label id='fnr.77' for='fnr-in.77.4157754' class='margin-toggle sidenote-number'><sup class='numeral'>77</sup></label><input type='checkbox' id='fnr-in.77.4157754' class='margin-toggle'><span class='sidenote'><sup class='numeral'>77</sup>
This is the crummier, brute-force version <br>

<table id="orgba92c8c">


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span> else<label id='fnr.78' for='fnr-in.78.5030949' class='margin-toggle sidenote-number'><sup class='numeral'>78</sup></label><input type='checkbox' id='fnr-in.78.5030949' class='margin-toggle'><span class='sidenote'><sup class='numeral'>78</sup>
Another attempt <br>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">0 min</td>
<td class="org-right">10 min</td>
<td class="org-right">20 min</td>
<td class="org-right">30 min</td>
<td class="org-right">40 min</td>
<td class="org-right">50 min</td>
</tr>

<tr>
<td class="org-right">20.0</td>
<td class="org-right">10.</td>
<td class="org-right">5.</td>
<td class="org-right">2.5</td>
<td class="org-right">1.25</td>
<td class="org-right">0.625</td>
</tr>
</tbody>
</table></span>
</p>

<p>
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank"><img src="./images/by-nc-sa.png" width="125px" style="padding: 100px 0px 0px 0px" alt="License-disense"</a>
</p>
</div>
</div>
</section>
</article>
</body>
</html>
