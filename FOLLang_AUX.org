# # -*- mode: org -*- coding: utf-8 -*-
#+TITLE: 
#+AUTHOR:
#+EMAIL: 
#+DATE: 
#+LANGUAGE:  en
# #+INFOJS_OPT: view:showall ltoc:t mouse:underline
#+HTML_HEAD: <link rel="stylesheet" href="./tufte.css" type="text/css">
#+HTML_HEAD: <link rel="stylesheet" href=".//ox-tufte.css" type="text/css">
#+HTML_HEAD_EXTRA: <style>
#+HTML_HEAD_EXTRA: article > div.org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-content-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: article > section .org-src-container {
#+HTML_HEAD_EXTRA:     width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     max-width: var(--ox-tufte-src-code-width);
#+HTML_HEAD_EXTRA:     clear: none;
#+HTML_HEAD_EXTRA: }
#+HTML_HEAD_EXTRA: div.org-src-container > pre { clear: none; }
#+HTML_HEAD_EXTRA: pre.example {clear: none; }
#+HTML_HEAD_EXTRA: </style>
#+INCLUDE: "./header.org" :minlevel 1
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_FILE_NAME: FirstOrderLanguageBuilding_Aux.html
#+OPTIONS: H:15 num:nil toc:nil \n:nil @:t ::t |:t _:{} *:t ^:{} prop:nil
#+OPTIONS: tex:t
#+OPTIONS: html-postamble:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [american]
# Setup tikz package for both LaTeX and HTML export:
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{commath}
#+LaTeX_HEADER: \usepackage{pgfplots}
#+LaTeX_HEADER: \usepackage{sansmath}
#+LaTeX_HEADER: \usepackage{mathtools}
#+PROPERTY: header-args:latex+ :packages '(("" "tikz"))
#
#+PROPERTY: header-args:latex+ :exports results :fit yes
#
#+STARTUP: showall
#+STARTUP: align
#+STARTUP: indent
#+STARTUP: shrink
# This makes MathJax/LaTeX appear in buffer (UTF-8)
#+STARTUP: entitiespretty
# #+STARTUP: logdrawer # This makes pictures appear in buffer
#+STARTUP: inlineimages
# #+STARTUP: latexpreview
#+STARTUP: fnadjust
# #+OPTIONS: html-style:nil
#+html_head_extra: <style> .title { display: none; } </style>
#+html_head_extra: <style> caption.t-bottom { caption-side: bottom; } </style>

* Getting started with logic

Here's a cogent quote from the most popular computer science textbook
on artificial intelligence, namely, /[[https://en.wikipedia.org/wiki/Artificial_Intelligence:_A_Modern_Approach][Artificial Intelligence A Modern
Approach]]/

#+begin_quote
In AI, /knowledge-based agents/ use a process of /reasoning/ over an
internal /representation/ of knowledge to decide what actions to take.
#+end_quote

Reasoning, in turn, is the domain of logic. We mention AI because in
today's world AI is at the forefront of applied logic. 

** Building Languages Using Logic

The natural progression of mathematical logic goes from
**Propositional Logic** to **First-Order Logic** (FOL). FOL offers an
abstract __language__ structure for a particular theory, such as our
topic, set theory. However, FOL is not meant to construct any sort of
natural language like English. And yet when we work with sets we're
speaking the language---using syntax, creating the semantics and
meaning---FOL provides for set theory.

We'll go over a bare minimum on this math holiday, leaving our main
discussion of logic for later. Logic is the math of math, and we'll
do our best to sort it out properly.

Most math texts gloss over the connection of set theory with the FOL
underpinnings, probably thinking it's not that critical. They try to
cruise through set theory without the "messy details" of the whys and
hows, no doubt to avoid getting too bogged down, too lost in the
weeds. But then situations appear that really should be backed up by a
deeper understanding --- but then the hand-waving starts. We're very
against hand-waving, because it always comes back to haunt us in the
end.

First, we'll explore what a /formal language/ is in this abstract
mathematical sense. What exactly is FOL facilitating? This should be
answered next.

*** Beginner Synopsis of Formal Language Theory

In everyday life, a spoken, written, printed language like English is,
from a strictly logical standpoint, "messy," full of contextual
nuances, hidden logical entailment, exceptions, paradoxes, ironical
twisting... And yet we often intend to juggle words and sentences
toward being logical and precise.

Just a simple, innocuous phrase like "how many?" is fraught. In
everyday usage "how many?" is a request for a count, a total. But the
word /how/ is typically a request to /elaborate on, explain a
process/, such as, "how did you do that?"  or "how did you get here?"
And so a literal interpretation of "how many?" is, "how did the state
of many come to be?" But no, in English that would be, "how then so
many?" As you can now imagine, all the twists and turns, all the
layers of logical entailment in regular spoken language quickly become
unmanageably large.[fn:1]

We've internalized our everyday language since early
childhood. Phrases and sentences just flow out. We're adept at literal
and figurative turns of speech. Creative tweaking and torquing our
languages is our main sport. Consider poetry. One of the "densest"
poets ever was Emily Dickinson

#+begin_verse
A Dew sufficed itself ---
And satisfied a Leaf ---
And felt 'how vast a Destiny' ---
'How trivial is Life'!
#+end_verse

When we start Kindergarden we watch and
listen and interact with this back-and-forth of language. But how
should a computer learn?  For the longest time the answer was, We
/program/ a computer. How?  With programs written in programming
languages. But programming languages, even the "friendliest," are
typically far from actual human language.

In mathematics and computer science, what is known as a **formal
language** strips all of the confusion, all the mess away. The goal of
human speech is to convey meaning. But a formal language in the logic
and computer science world is not about qualitative, subjective
understanding; it is purely about /structure, rules,/ and /pattern
matching/. Thus, a formal language does not intend to describe what
things /mean/. It only cares about how symbols are allowed to be
/arranged/. Again, we have in higher math's formal language theory a
methodology compatible with the computer. Once again it's formalize to operationalize.

**** 1. The Alphabet (The Raw Material)

Every formal language starts with a strictly defined set of allowable symbols. This is just an inventory of characters.

- In basic arithmetic, the alphabet might be: $\{0, 1, 2, +, =, (, )\}$
- In standard set theory, it might be the universal logical symbols plus exactly one relation symbol: $\{\forall, \exists, \land, \lor, \lnot, (, ), x, y, \in\}$
- In a computational environment, it is often just the standard ASCII or Unicode character set.

**** 2. Strings / Words (The Combinations)
A "string" (sometimes called a "word") is simply any finite sequence of symbols taken from the alphabet and smashed together. At this stage, there are no rules.

- String A: $\forall x\, (x \in y)$
- String B: $) \forall \forall \in x y \land$
- String C: =(define (square x) (* x x))=
- String D: =)) define ( ( *=

**** 3. The Formal Language (The Rules)
This is the main event. A formal language is not a loose concept; it is literally defined as *a specific set of strings* that obey a strict set of grammatical rules (often called a formal grammar, syntax, or formation rules). 

If a string follows the rules, it is "in the language" (it is a Well-Formed Formula, or valid syntax). If it breaks even one rule, it is "not in the language."

- String A and String C follow the structural rules of their respective domains. They belong to the formal language.
- String B and String D have mismatched parentheses and operators in the wrong places. They are structurally invalid and are rejected from the language.

**** 1. What Is a Formal Language?

A *formal language* is a precisely defined set of strings built from a
fixed collection of symbols following a given set of rules. At its
core a formal language is always just a set of strings.

**** 2. Alphabet and Strings

Like a natural language everything starts with an **alphabet**. An
alphabet (usually written $\Sigma$) is a finite set of symbols.

Example:

- $\Sigma = \{0,1\}$
- $\Sigma = \{a,b,c\}$
- $\Sigma = \{(,)\}$

A *string* is a finite sequence of symbols from the alphabet.

Examples over $\Sigma = \{a,b\}$:

- $a$
- $ab$
- $aab$
- $abba$

The empty string is written:

- $\epsilon$

**** 3. A Language Is a Set of Strings

Once you have all possible strings over $\Sigma$, a formal language is just
some subset of them.

Example:

If $\Sigma = \{0,1\}$, then all possible strings include:

- $\epsilon$
- $0$
- $1$
- $00$
- $01$
- $10$
- $11$
- $000$
- $\dots$

Now define a language:

$L =$ “all strings with an even number of $0$s”

That is a formal language.

Another example:

$L = \{ a^n b^n \mid n \ge 0 \}$

This means:

- $\epsilon$
- $ab$
- $aabb$
- $aaabbb$
- $\dots$

**** 4. How Do We Describe Languages?

There are three major ways.

***** (1) By Listing Them

Possible only for small finite languages.

Example:

$L = \{a, ab, abb\}$

***** (2) By Rules (Grammars)

A grammar tells you how to generate strings.

Example rules:

$S \to aSb$  
$S \to \epsilon$

This generates:

- $\epsilon$
- $ab$
- $aabb$
- $aaabbb$
- $\dots$

***** (3) By Machines (Automata)

A machine reads a string and decides whether to accept it.

Examples:

- Finite automata
- Pushdown automata
- Turing machines

A deep result:

Grammars, machines, and logical definitions often describe the same classes
of languages.

**** 5. Syntax vs Meaning

Formal language theory studies:

- Syntax (structure)

It does *not* study:

- Meaning (semantics)

Example:

The string:

$aabbb$

Formal language theory asks:

Is it in the set?

It does not ask:

What does it mean?

**** 6. The Chomsky Hierarchy

Languages fall into types depending on structural complexity.

From simplest to most powerful:

1. Regular languages  
   - Recognized by finite automata  
   - No memory  

2. Context-free languages  
   - Recognized by pushdown automata  
   - Have stack memory  
   - Handle nested structure  

3. Context-sensitive languages  

4. Recursively enumerable languages  
   - Recognized by Turing machines  

Each level allows more complex patterns.

**** 7. Connecting Formal Languages to First-Order Logic

First-order logic itself is a formal language.

To define it formally, we specify:

***** Alphabet of First-Order Logic

Example alphabet:

- Logical symbols: $\forall, \exists, \neg, \land, \lor, \rightarrow, =$  
- Variables: $x, y, z, x_1, x_2, \dots$  
- Parentheses: $(,)$  
- Predicate symbols: $P, Q, R, \dots$  
- Function symbols: $f, g, \dots$  
- Constant symbols: $a, b, c, \dots$

This collection of symbols forms an alphabet $\Sigma_{FOL}$.

***** Strings

Any finite sequence of these symbols is a string.

Example of a string:

$\forall x ( P(x) \rightarrow Q(x) )$

But not every string is *well-formed*.

***** Well-Formed Formulas (WFFs)

We define formation rules inductively:

1. If $P$ is an $n$-ary predicate and $t_1, \dots, t_n$ are terms,
   then $P(t_1, \dots, t_n)$ is a formula.

2. If $\varphi$ and $\psi$ are formulas, then:
   - $\neg \varphi$
   - $(\varphi \land \psi)$
   - $(\varphi \rightarrow \psi)$

3. If $\varphi$ is a formula and $x$ a variable:
   - $\forall x \varphi$
   - $\exists x \varphi$

The *formal language of first-order logic* is the set of all strings
generated by these formation rules.

Thus:

First-order logic = a formally defined language of well-formed formulas.

**** 8. Peano Arithmetic as a Formal Language

Peano Arithmetic (PA) is a specific first-order language plus axioms.

***** Alphabet of PA

It includes:

- Constant symbol: $0$
- Function symbols:
  - $S$ (successor)
  - $+$ (addition)
  - $\cdot$ (multiplication)
- Equality symbol: $=$
- Logical symbols:
  - $\forall, \exists, \neg, \land, \lor, \rightarrow$
- Variables: $x, y, z, \dots$

***** Terms

Defined inductively:

- $0$ is a term.
- If $t$ is a term, then $S(t)$ is a term.
- If $t_1, t_2$ are terms:
  - $(t_1 + t_2)$
  - $(t_1 \cdot t_2)$

***** Formulas

If $t_1$ and $t_2$ are terms:

- $t_1 = t_2$ is a formula.

From these, more complex formulas are built using logical symbols.

Example formulas:

- $\forall x (x + 0 = x)$
- $\forall x \forall y (x + S(y) = S(x + y))$

***** Axioms of PA

Examples:

1. $\forall x \neg (S(x) = 0)$
2. $\forall x \forall y (S(x) = S(y) \rightarrow x = y)$
3. Induction schema:
   If $\varphi(0)$ and
   $\forall x (\varphi(x) \rightarrow \varphi(S(x)))$,
   then $\forall x \varphi(x)$.

Thus:

Peano Arithmetic is:

- A formal language (its symbols and formation rules)
- Plus a set of axioms (special formulas inside that language)

**** 9. Big Picture

A formal language is:

- An alphabet $\Sigma$
- A set of formation rules
- A resulting set of strings

First-order logic is a formal language.

Peano arithmetic is:

A particular first-order formal language designed to describe natural numbers.

Meaning (semantics) comes later, when we interpret:

- $0$ as the number zero
- $S$ as the successor function
- $+$ as addition

But syntactically, it is just symbol manipulation.

This separation between:

- Syntax (formal language)
- Semantics (interpretation)

is one of the deepest ideas in modern logic.
```


*** Main Differences Between Propositional Logic and First-Order Logic

The main differences concern *what they can talk about* and how much internal
structure their statements have.

**** Propositional Logic

***** Basic Idea

Propositional logic treats whole statements as indivisible atoms.

Examples:

- $P$ : “It is raining.”
- $Q$ : “The ground is wet.”

You can form compound statements:

- $P \land Q$
- $P \rightarrow Q$
- $\neg P$

***** Key Features

- Atomic units are whole propositions.
- Logical connectives:
  - $\neg$ (not)
  - $\land$ (and)
  - $\lor$ (or)
  - $\rightarrow$ (implies)
  - $\leftrightarrow$ (if and only if)
- No variables
- No quantifiers
- No internal structure inside propositions

***** Limitation

It cannot express statements like:

“All humans are mortal.”

Because propositional logic cannot refer to objects inside statements.
It only sees complete statements as black boxes.

**** First-Order Logic (FOL)

First-order logic extends propositional logic by allowing us to talk about:

- Objects
- Properties of objects
- Relations between objects
- Quantification over objects

***** New Components in First-Order Logic

****** 1. Variables

Symbols like:

- $x$
- $y$
- $z$

These range over objects in a domain.

****** 2. Predicates

Instead of atomic propositions like $P$, we have predicates applied to terms:

- $\mathrm{Human}(x)$
- $\mathrm{Loves}(x,y)$

Predicates express properties and relations.

****** 3. Quantifiers

This is the major expansion.

- Universal quantifier:
  - $\forall x$
- Existential quantifier:
  - $\exists x$

Now we can express:

- $\forall x \, (\mathrm{Human}(x) \rightarrow \mathrm{Mortal}(x))$

This was impossible in propositional logic.

****** 4. Functions (optional but common)

Example:

- $\mathrm{Father}(x)$

Which allows nested structure:

- $\mathrm{Human}(\mathrm{Father}(x))$

**** What Extra Abilities Does First-Order Logic Bring?

***** Ability 1: Talk About Individuals

Propositional logic:

- $P$ : “Socrates is mortal.”

First-order logic:

- $\mathrm{Mortal}(\mathrm{Socrates})$

Now the internal structure is visible.

***** Ability 2: Express General Laws

Propositional logic must list cases:

- $P_1 \land P_2 \land P_3 \land \dots$

First-order logic expresses them compactly:

- $\forall x \, (\mathrm{Human}(x) \rightarrow \mathrm{Mortal}(x))$

***** Ability 3: Express Existence

Propositional logic cannot naturally express:

“There exists someone who loves everyone.”

First-order logic:

- $\exists x \, \forall y \, \mathrm{Loves}(x,y)$

***** Ability 4: Express Relations

Propositional logic cannot express:

“Everyone loves someone.”

First-order logic:

- $\forall x \, \exists y \, \mathrm{Loves}(x,y)$

***** Ability 5: Express Mathematical Structure

Arithmetic needs quantification:

- $\forall x \, (x + 0 = x)$

Propositional logic cannot express arithmetic laws.

**** Expressive Power Comparison

| Feature                     | Propositional Logic | First-Order Logic |
|-----------------------------+---------------------+-------------------|
| Logical connectives         | Yes                 | Yes               |
| Variables                   | No                  | Yes               |
| Predicates                  | No                  | Yes               |
| Quantifiers                 | No                  | Yes               |
| Relations                   | No                  | Yes               |
| Arithmetic expressible      | No                  | Yes               |
| Talks about individuals     | No                  | Yes               |

**** Cost of Extra Power

The extra expressive power comes with trade-offs:

- Propositional logic is decidable (truth tables always work).
- First-order logic is not decidable in general.
- First-order reasoning is more complex.

**** Conceptual Summary

- Propositional logic talks about whole facts.
- First-order logic talks about objects inside facts.

Propositional logic says:

“This statement is true.”

First-order logic says:

“For every object in the universe, this property holds.”
```

*** FOL Components

Back to FOL...

A first-order language is created by specifying:

1. Its symbols (vocabulary)
2. Rules for forming expressions (syntax)
3. Rules for assigning meaning (semantics)

Together, these define a complete formal language.

**** 1. Vocabulary (Alphabet of the Language)

To construct a first-order language, we first define its symbols.

***** A. Logical Symbols (Built-In)

These are common to all first-order languages:

- Quantifiers:
  - $\forall$ (for all)
  - $\exists$  (there exists)

- Logical connectives:
  - $\lnot$  (not)
  - $\land$  (and)
  - $\lor$  (or)
  - $\implies$  (implies)
  - $\iff$  (if and only if)

- Variables:
  - $x$, $y$, $z$, ...

- Equality (optional but common):
  - $=$

***** B. Non-Logical Symbols (Domain-Specific)

These depend on what the language is about.

1. Constant symbols (name specific objects)
   - $a$, $b$, $john$

2. Function symbols (map objects to objects)
   - $father(x)$
   - $plus(x, y)$

3. Predicate symbols (properties or relations)
   - ~Human(x)~
   - ~Loves(x, y)~
   - ~Prime(x)~

The choice of these symbols determines what the language can express.

**** 2. Syntax: Building Well-Formed Formulas

Syntax specifies how symbols may be combined.

***** Step 1: Terms

Terms refer to objects.

A term can be:
- A variable ($x$)
- A constant ($john$)
- A function applied to terms ($father(x)$, $plus(x, y)$)

***** Step 2: Atomic Formulas

An atomic formula is a predicate applied to terms.

Examples:
- ~Human(x)~
- ~Loves(john, mary)~
- ~Prime(7)~

***** Step 3: Complex Formulas

Formulas can be combined using logical connectives and quantifiers.

Examples:
- $\lnot Human(x)$
- $Human(x) \land Mortal(x)$
- $\forall x (Human(x) \implies Mortal(x))$
- $\exists x | Loves(x, mary)$

These formation rules define what counts as a grammatically correct
sentence.

**** 3. Semantics: Giving Meaning

Syntax defines structure.
Semantics defines meaning.

To interpret a first-order language, we specify:

1. A domain of discourse (the set of objects being discussed)
2. An interpretation that assigns:
   - Each constant → an object in the domain
   - Each function → a mapping over the domain
   - Each predicate → a relation over the domain

***** Example interpretation:

Domain: all people

Human(x): "x is a person"
Mortal(x): "x eventually dies"

Then the sentence:

  ∀x (Human(x) → Mortal(x))

means:

  For every object in the domain,
  if it is human, then it is mortal.

**** 4. How This Creates a Language

A first-order language is created by:

1. Defining a vocabulary
2. Defining formation rules (syntax)
3. Defining interpretation rules (semantics)

Comparison:

| Natural Language | First-Order Logic |
|------------------+------------------|
| Words            | Symbols          |
| Grammar rules    | Formation rules  |
| Contextual meaning | Interpretation |

First-order logic removes ambiguity by enforcing precise structure and meaning.

**** 5. Example: Constructing a Simple Language

Suppose we want a language about family relationships.

***** Vocabulary

- Constant: john
- Predicate: Parent(x, y)
- Predicate: Male(x)

***** Sentence

  ∀x (Parent(john, x) → Male(john))

Meaning:

  For every x,
  if john is a parent of x,
  then john is male.

This is a complete sentence in a first-order language.

**** 6. Why This Matters

First-order logic is used to construct:

- Mathematical theories
- Knowledge representation systems
- Database query systems
- Programming language semantics
- Artificial intelligence reasoning systems

It provides the structural foundation for precise formal reasoning.

**** Summary

First-order logic creates a language by providing:

1. Symbols (vocabulary)
2. Grammar rules (syntax)
3. Interpretation rules (semantics)

The result is a precise, unambiguous formal language capable of expressing structured reasoning about objects and their relationships.



*** Building the Language of Set Theory Using First-Order Logic

**** Overview

Here we walk through how first-order logic (FOL) is used to build the
*language of set theory*, step by step, with detailed examples.

Set theory (specifically Zermelo–Fraenkel set theory, ZF) is formulated
entirely inside a first-order language. What makes it powerful is that
*everything is a set* — numbers, functions, relations, ordered pairs —
all are defined using only sets.

We will follow these five steps:

1. Specify the vocabulary
2. Define terms
3. Define atomic formulas
4. Build complex formulas
5. Provide semantics (interpretation)

---------------------------------------------------------------------

**** Step 1: Specify the Vocabulary

A first-order language consists of logical symbols plus non-logical symbols.

***** Logical Symbols (standard in all FOL)

- Quantifiers: ∀, ∃
- Connectives: ¬, ∧, ∨, →, ↔
- Variables: x, y, z, x₁, x₂, ...
- Equality: =

***** Non-Logical Symbols for Set Theory

In standard ZF set theory, the language is extremely minimal.

It contains only:

- One binary predicate symbol: ∈  (membership)

That’s it.

There are:
- No constant symbols
- No function symbols
- No additional predicates

Everything must be expressed using:
  =
  ∈
  logical symbols

This simplicity is one of the remarkable features of set theory.

---------------------------------------------------------------------

**** Step 2: Define Terms

In this language, terms are very simple.

Since there are:
- no constants
- no function symbols

The only terms are:

- Variables

Examples of terms:
- x
- y
- z
- x₁

That means every object referred to in the language is a variable.
Objects only gain meaning once interpreted in a model.

---------------------------------------------------------------------

**** Step 3: Atomic Formulas

Atomic formulas are the simplest meaningful statements.

Because the only non-logical symbol is ∈,
the only atomic formulas are:

1. x ∈ y
2. x = y

Examples:

- x ∈ y
- y ∈ z
- x = y
- x ∈ x

Even something like:

  "x is a subset of y"

is not primitive. It must be defined using ∈:

  x ⊆ y  is shorthand for:

  ∀z (z ∈ x → z ∈ y)

So subset is not a new symbol —
it is a defined abbreviation inside the language.

---------------------------------------------------------------------

**** Step 4: Build Complex Formulas

Now we use logical connectives and quantifiers
to build meaningful mathematical statements.

Here are important examples.

--------------------------------------------------
***** Example 1: The Empty Set

We want to say:

  There exists a set with no elements.

Formal version:

  ∃x ∀y ¬(y ∈ x)

This says:

  There exists x such that
  for every y,
  y is not an element of x.

--------------------------------------------------
***** Example 2: Subset Relation

Define:

  x ⊆ y

as:

  ∀z (z ∈ x → z ∈ y)

Now we can express:

  x = y  iff  x ⊆ y ∧ y ⊆ x

Which expands fully to:

  ∀z (z ∈ x ↔ z ∈ y)

--------------------------------------------------
***** Example 3: Pairing Axiom

Informally:

  For any x and y,
  there exists a set containing exactly x and y.

Formal version:

  ∀x ∀y ∃z ∀w (w ∈ z ↔ (w = x ∨ w = y))

This expresses the existence of {x, y}.

--------------------------------------------------
***** Example 4: Union Axiom

Informally:

  For any set x,
  there exists a set containing all elements of elements of x.

Formal version:

  ∀x ∃u ∀z (z ∈ u ↔ ∃y (y ∈ x ∧ z ∈ y))

This defines ⋃x.

--------------------------------------------------
***** Example 5: Defining Ordered Pairs

Ordered pairs are not primitive.
They are defined using sets.

Kuratowski definition:

  (x, y) = {{x}, {x, y}}

Each part of this definition must itself
be built using earlier axioms (pairing, union, etc.).

So even ordered pairs reduce to pure membership structure.

--------------------------------------------------
***** Example 6: Defining Natural Numbers

In set theory:

0 = ∅
1 = {∅}
2 = {∅, {∅}}
3 = {∅, {∅}, {∅, {∅}}}
...

Each number is defined as:

  n = {0, 1, ..., n-1}

So arithmetic is encoded entirely using sets.

---------------------------------------------------------------------

**** Step 5: Semantics (Interpretation)

To interpret this language, we specify:

1. A domain
2. An interpretation of ∈

In set theory, a model consists of:

- A collection M of objects
- A binary relation E on M

The formula:

  x ∈ y

means:

  x is related to y by E.

If the structure satisfies all axioms of ZF,
it is called a *model of set theory*.

Inside the intended model:

- The domain is the cumulative hierarchy of sets
- ∈ is actual set membership

But other, nonstandard models also exist.

---------------------------------------------------------------------

**** What Makes This Powerful?

With only:

  ∈
  =
  logical symbols

we can define:

- subsets
- unions
- intersections
- ordered pairs
- relations
- functions
- natural numbers
- real numbers
- metric spaces
- groups
- topological spaces

All of modern mathematics can be formalized
inside this tiny first-order language.

---------------------------------------------------------------------

**** Big Picture Summary

When first-order logic is applied to set theory:

1. The vocabulary is reduced to a single primitive relation (∈).
2. Terms are only variables.
3. Atomic formulas are membership or equality statements.
4. All mathematics is built using quantified combinations of those.
5. Meaning is given by a model consisting of a domain and a membership relation.

This shows how an entire mathematical universe
can be constructed from a minimal first-order language.

* Footnotes

[fn:1] ...so if everyday English is so crazy, how then is LLM (large
language model) AI (e.g., ChatGPT) able to hold a decent, albeit
sometimes wooden conversation with us?  Hold that thought...
